<?xml version="1.0"?>
<doc>
    <assembly>
        <name>C5</name>
    </assembly>
    <members>
        <member name="T:C5.ArrayList`1">
             <summary>
             A list collection based on a plain dynamic array data structure.
             Expansion of the internal array is performed by doubling on demand. 
             The internal array is only shrinked by the Clear method. 
            
             <i>When the FIFO property is set to false this class works fine as a stack of T.
             When the FIFO property is set to true the class will function as a (FIFO) queue
             but very inefficiently, use a LinkedList (<see cref="T:C5.LinkedList`1"/>) instead.</i>
             </summary>
        </member>
        <member name="F:C5.ArrayList`1.isValid">
            <summary>
            Has this list or view not been invalidated by some operation (by someone calling Dispose())
            </summary>
        </member>
        <member name="F:C5.ArrayList`1.underlying">
            <summary>
            The underlying list if we are a view, null else.
            </summary>
        </member>
        <member name="P:C5.ArrayList`1.underlyingsize">
            <summary>
            The size of the underlying list.
            </summary>
        </member>
        <member name="F:C5.ArrayList`1.fIFO">
            <summary>
            The underlying field of the FIFO property
            </summary>
        </member>
        <member name="P:C5.ArrayList`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.ArrayList`1.addtosize(System.Int32)">
            <summary>
            Increment or decrement the private size fields
            </summary>
            <param name="delta">Increment (with sign)</param>
        </member>
        <member name="M:C5.ArrayList`1.expand">
            <summary>
            Double the size of the internal array.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.expand(System.Int32,System.Int32)">
            <summary>
            Expand the internal array, resetting the index of the first unused element.
            </summary>
            <param name="newcapacity">The new capacity (will be rounded upwards to a power of 2).</param>
            <param name="newsize">The new count of </param>
        </member>
        <member name="M:C5.ArrayList`1.updatecheck">
            <summary>
            Check if it is valid to perform updates and increment stamp if so.
            </summary>
            <exception cref="T:C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
            <exception cref="T:C5.ReadOnlyCollectionException"> If check fails by this being a read only list.</exception>
        </member>
        <member name="M:C5.ArrayList`1.validitycheck">
            <summary>
            Check if we are a view that the underlying list has only been updated through us.
            <para>This method should be called from enumerators etc to guard against 
            modification of the base collection.</para>
            </summary>
            <exception cref="T:C5.ViewDisposedException"> if check fails.</exception>
        </member>
        <member name="M:C5.ArrayList`1.modifycheck(System.Int32)">
            <summary>
            Check that the list has not been updated since a particular time.
            <para>To be used by enumerators and range </para>
            </summary>
            <exception cref="T:C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
            <exception cref="T:C5.CollectionModifiedException">If the list *has* been updated since that  time..</exception>
            <param name="stamp">The stamp indicating the time.</param>
        </member>
        <member name="M:C5.ArrayList`1.indexOf(`0)">
            <summary>
            Internal version of IndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of first occurrence</returns>
        </member>
        <member name="M:C5.ArrayList`1.lastIndexOf(`0)">
            <summary>
            Internal version of LastIndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of last occurrence</returns>
        </member>
        <member name="M:C5.ArrayList`1.InsertProtected(System.Int32,`0)">
            <summary>
            Internal version of Insert with no modification checks.
            </summary>
            <param name="i">Index to insert at</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:C5.ArrayList`1.removeAt(System.Int32)">
            <summary>
            Internal version of RemoveAt with no modification checks.
            </summary>
            <param name="i">Index to remove at</param>
            <returns>The removed item</returns>
        </member>
        <member name="M:C5.ArrayList`1.fixViewsAfterInsert(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="added">The actual number of inserted nodes</param>
            <param name="realInsertionIndex"></param>
        </member>
        <member name="M:C5.ArrayList`1.fixViewsBeforeRemove(System.Int32,System.Int32)">
            <summary>
            Fix offsets and sizes of other views before removing an interval from this 
            </summary>
            <param name="start">the start of the interval relative to the array/underlying</param>
            <param name="count"></param>
        </member>
        <member name="M:C5.ArrayList`1.viewPosition(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="otherOffset"></param>
            <param name="otherSize"></param>
            <returns>The position of View(otherOffset, otherSize) wrt. this view</returns>
        </member>
        <member name="T:C5.ArrayList`1.Position">
            <summary>
            During RemoveAll, we need to cache the original endpoint indices of views (??? also for ArrayList?)
            </summary>
        </member>
        <member name="T:C5.ArrayList`1.ViewHandler">
            <summary>
            Handle the update of (other) views during a multi-remove operation.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.ViewHandler.skipEndpoints(System.Int32,System.Int32)">
            <summary>
            This is to be called with realindex pointing to the first node to be removed after a (stretch of) node that was not removed
            </summary>
            <param name="removed"></param>
            <param name="realindex"></param>
        </member>
        <member name="M:C5.ArrayList`1.#ctor">
            <summary>
            Create an array list with default item equalityComparer and initial capacity 8 items.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an array list with external item equalityComparer and initial capacity 8 items.
            </summary>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.ArrayList`1.#ctor(System.Int32)">
            <summary>
            Create an array list with default item equalityComparer and prescribed initial capacity.
            </summary>
            <param name="capacity">The prescribed capacity</param>
        </member>
        <member name="M:C5.ArrayList`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an array list with external item equalityComparer and prescribed initial capacity.
            </summary>
            <param name="capacity">The prescribed capacity</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="P:C5.ArrayList`1.First">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.ArrayList`1.Last">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.ArrayList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. The default for a new array list is false.</value>
        </member>
        <member name="P:C5.ArrayList`1.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.ArrayList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
            <value>The index'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.ArrayList`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.ArrayList`1.Insert(System.Int32,`0)">
             <summary>
             Insert an item at a specific index location in this list. 
            </summary>
             <exception cref="T:System.IndexOutOfRangeException"> if i is negative or
             &gt; the size of the collection. </exception>
             <param name="index">The index at which to insert.</param>
             <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.Insert(C5.IList{`0},`0)">
            <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoint of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para>
            </summary>
            <exception cref="T:C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on or the same list as <code>this</code></exception>
            <exception cref="T:System.IndexOutOfRangeException"><b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.ArrayList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt; the size of the collection.</exception>
            <param name="index">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list;
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            <para>The new list will be of type ArrayList</para>
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default item equalityComparer for the item type V.
            <para>The new list will be of type ArrayList</para>
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified item equalityComparer for the item type.
            <para>The new list will be of type ArrayList</para>
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="itemequalityComparer">The item equalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative
            or the range does not fit within list.</exception>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.ArrayList`1.ViewOf(`0)">
            <summary>
            Create a list view on this list containing the (first) occurrence of a particular item.
            <para>Returns <code>null</code> if the item is not in this list.</para>
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.ArrayList`1.LastViewOf(`0)">
            <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <para>Returns <code>null</code> if the item is not in this list.</para>
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="P:C5.ArrayList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.ArrayList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for an underlying list.</value>
        </member>
        <member name="P:C5.ArrayList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.ArrayList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.ArrayList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.ArrayList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.Span(C5.IList{`0})">
            <summary>
            
            <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
            </summary>
            <param name="otherView"></param>
            <exception cref="T:C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.IsSorted">
            <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.ArrayList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Sort">
            <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class 
            (<see cref="T:C5.Comparer`1"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
        </member>
        <member name="M:C5.ArrayList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
            <param name="comparer">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.ArrayList`1.Shuffle">
            <summary>
            Randomly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="M:C5.ArrayList`1.IndexOf(`0)">
            <summary>
            Search for an item in the list going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.ArrayList`1.LastIndexOf(`0)">
            <summary>
            Search for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from the end.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
            <param name="index">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If <code>start</code>
            and <code>count</code> does not describe a valid interval in the list</exception> 
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="P:C5.ArrayList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Linear</value>
        </member>
        <member name="M:C5.ArrayList`1.GetUnsequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.ArrayList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            matching item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ArrayList`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.Remove(`0)">
            <summary>
            Remove a particular item from this list. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ArrayList`1.Remove(`0,`0@)">
            <summary>
            Remove the first copy of a particular item from this collection if found.
            If an item was removed, report a binary copy of the actual item removed in 
            the argument. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            Matching items will be removed from the front. Current implementation is not optimal.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.ArrayList`1.Clear">
            <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            Items are retained front first.  
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.ArrayList`1.RetainAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.ArrayList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection,
            taking multiplicities into account.
            Current implementation is not optimal.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.ArrayList`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equal to a given one.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.ArrayList`1.Check">
            <summary>
            Check the integrity of the internal data structures of this array list.
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.ArrayList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True, indicating array list has bag semantics.</value>
        </member>
        <member name="P:C5.ArrayList`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.ArrayList`1.Add(`0)">
            <summary>
            Add an item to end of this list.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True</returns>
        </member>
        <member name="M:C5.ArrayList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.ArrayList`1.C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.ArrayList`1.Count">
            <summary>
            
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="M:C5.ArrayList`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.ArrayList`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.ArrayList`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Enqueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.ArrayList`1.Dequeue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="M:C5.ArrayList`1.Dispose">
            <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
        </member>
        <member name="T:C5.CircularQueue`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:C5.CircularQueue`1.array">
            <summary>
            The internal container array is doubled when necessary, but never shrinked.
            </summary>
        </member>
        <member name="P:C5.CircularQueue`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.CircularQueue`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.CircularQueue`1.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="P:C5.CircularQueue`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.CircularQueue`1.Item(System.Int32)">
            <summary>
            Get the i'th item in the queue. The front of the queue is at index 0.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.Enqueue(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.CircularQueue`1.Dequeue">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.Push(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.CircularQueue`1.Pop">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.Choose">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.CircularQueue`1.Check">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.HashedArrayList`1">
             <summary>
             A list collection based on a plain dynamic array data structure.
             Expansion of the internal array is performed by doubling on demand. 
             The internal array is only shrinked by the Clear method. 
            
             <i>When the FIFO property is set to false this class works fine as a stack of T.
             When the FIFO property is set to true the class will function as a (FIFO) queue
             but very inefficiently, use a LinkedList (<see cref="T:C5.LinkedList`1"/>) instead.</i>
             </summary>
        </member>
        <member name="F:C5.HashedArrayList`1.isValid">
            <summary>
            Has this list or view not been invalidated by some operation (by someone calling Dispose())
            </summary>
        </member>
        <member name="F:C5.HashedArrayList`1.underlying">
            <summary>
            The underlying list if we are a view, null else.
            </summary>
        </member>
        <member name="P:C5.HashedArrayList`1.underlyingsize">
            <summary>
            The size of the underlying list.
            </summary>
        </member>
        <member name="F:C5.HashedArrayList`1.fIFO">
            <summary>
            The underlying field of the FIFO property
            </summary>
        </member>
        <member name="P:C5.HashedArrayList`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashedArrayList`1.addtosize(System.Int32)">
            <summary>
            Increment or decrement the private size fields
            </summary>
            <param name="delta">Increment (with sign)</param>
        </member>
        <member name="M:C5.HashedArrayList`1.expand">
            <summary>
            Double the size of the internal array.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.expand(System.Int32,System.Int32)">
            <summary>
            Expand the internal array, resetting the index of the first unused element.
            </summary>
            <param name="newcapacity">The new capacity (will be rounded upwards to a power of 2).</param>
            <param name="newsize">The new count of </param>
        </member>
        <member name="M:C5.HashedArrayList`1.updatecheck">
            <summary>
            Check if it is valid to perform updates and increment stamp if so.
            </summary>
            <exception cref="T:C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
            <exception cref="T:C5.ReadOnlyCollectionException"> If check fails by this being a read only list.</exception>
        </member>
        <member name="M:C5.HashedArrayList`1.validitycheck">
            <summary>
            Check if we are a view that the underlying list has only been updated through us.
            <para>This method should be called from enumerators etc to guard against 
            modification of the base collection.</para>
            </summary>
            <exception cref="T:C5.ViewDisposedException"> if check fails.</exception>
        </member>
        <member name="M:C5.HashedArrayList`1.modifycheck(System.Int32)">
            <summary>
            Check that the list has not been updated since a particular time.
            <para>To be used by enumerators and range </para>
            </summary>
            <exception cref="T:C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
            <exception cref="T:C5.CollectionModifiedException">If the list *has* been updated since that  time..</exception>
            <param name="stamp">The stamp indicating the time.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.indexOf(`0)">
            <summary>
            Internal version of IndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of first occurrence</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.lastIndexOf(`0)">
            <summary>
            Internal version of LastIndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of last occurrence</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertProtected(System.Int32,`0)">
            <summary>
            Internal version of Insert with no modification checks.
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException"> if item already in list.</exception>
            <param name="i">Index to insert at</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:C5.HashedArrayList`1.removeAt(System.Int32)">
            <summary>
            Internal version of RemoveAt with no modification checks.
            </summary>
            <param name="i">Index to remove at</param>
            <returns>The removed item</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.fixViewsAfterInsert(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="added">The actual number of inserted nodes</param>
            <param name="realInsertionIndex"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.fixViewsBeforeRemove(System.Int32,System.Int32)">
            <summary>
            Fix offsets and sizes of other views before removing an interval from this 
            </summary>
            <param name="start">the start of the interval relative to the array/underlying</param>
            <param name="count"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.viewPosition(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="otherOffset"></param>
            <param name="otherSize"></param>
            <returns>The position of View(otherOffset, otherSize) wrt. this view</returns>
        </member>
        <member name="T:C5.HashedArrayList`1.Position">
            <summary>
            During RemoveAll, we need to cache the original endpoint indices of views (??? also for HashedArrayList?)
            </summary>
        </member>
        <member name="T:C5.HashedArrayList`1.ViewHandler">
            <summary>
            Handle the update of (other) views during a multi-remove operation.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.ViewHandler.skipEndpoints(System.Int32,System.Int32)">
            <summary>
            This is to be called with realindex pointing to the first node to be removed after a (stretch of) node that was not removed
            </summary>
            <param name="removed"></param>
            <param name="realindex"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor">
            <summary>
            Create an array list with default item equalityComparer and initial capacity 8 items.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an array list with external item equalityComparer and initial capacity 8 items.
            </summary>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor(System.Int32)">
            <summary>
            Create an array list with default item equalityComparer and prescribed initial capacity.
            </summary>
            <param name="capacity">The prescribed capacity</param>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an array list with external item equalityComparer and prescribed initial capacity.
            </summary>
            <param name="capacity">The prescribed capacity</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="P:C5.HashedArrayList`1.First">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.HashedArrayList`1.Last">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.HashedArrayList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. The default for a new array list is false.</value>
        </member>
        <member name="P:C5.HashedArrayList`1.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.HashedArrayList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> By the get operation
            if the item already is present somewhere else in the list.</exception>
            <value>The index'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.HashedArrayList`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashedArrayList`1.Insert(System.Int32,`0)">
             <summary>
             Insert an item at a specific index location in this list. 
            </summary>
             <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
             &gt; the size of the collection. </exception>
             <exception cref="T:C5.DuplicateNotAllowedException"> 
             If the item is already present in the list.</exception>
             <param name="index">The index at which to insert.</param>
             <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Insert(C5.IList{`0},`0)">
            <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoint of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para>
            </summary>
            <exception cref="T:C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on or the same list as <code>this</code></exception>
            <exception cref="T:System.IndexOutOfRangeException"><b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt; the size of the collection.</exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> If <code>items</code> 
            contains duplicates or some item already  present in the list.</exception>
            <param name="index">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list;
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException">If the item is already in the list</exception>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException">If the item is already in the list</exception>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            <para>The new list will be of type HashedArrayList</para>
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default item equalityComparer for the item type V.
            <para>The new list will be of type HashedArrayList</para>
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException">If <code>mapper</code>
            creates duplicates</exception>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified item equalityComparer for the item type.
            <para>The new list will be of type HashedArrayList</para>
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException">If <code>mapper</code>
            creates duplicates</exception>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="itemequalityComparer">The item equalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative
            or the range does not fit within list.</exception>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.ViewOf(`0)">
            <summary>
            Create a list view on this list containing the (first) occurrence of a particular item.
            <para>Returns <code>null</code> if the item is not in this list.</para>
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.LastViewOf(`0)">
            <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <para>Returns <code>null</code> if the item is not in this list.</para>
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="P:C5.HashedArrayList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.HashedArrayList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for an underlying list.</value>
        </member>
        <member name="P:C5.HashedArrayList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashedArrayList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Span(C5.IList{`0})">
            <summary>
            
            <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
            </summary>
            <param name="otherView"></param>
            <exception cref="T:C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.IsSorted">
            <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Sort">
            <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class 
            (<see cref="T:C5.Comparer`1"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
        </member>
        <member name="M:C5.HashedArrayList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
            <param name="comparer">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Shuffle">
            <summary>
            Randomly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.IndexOf(`0)">
            <summary>
            Search for an item in the list going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.LastIndexOf(`0)">
            <summary>
            Search for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from the end.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
            <param name="index">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If <code>start</code>
            and <code>count</code> does not describe a valid interval in the list</exception> 
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="P:C5.HashedArrayList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Linear</value>
        </member>
        <member name="M:C5.HashedArrayList`1.GetUnsequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            matching item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Remove(`0)">
            <summary>
            Remove a particular item from this list. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Remove(`0,`0@)">
            <summary>
            Remove the first copy of a particular item from this collection if found.
            If an item was removed, report a binary copy of the actual item removed in 
            the argument. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            Matching items will be removed from the front. Current implementation is not optimal.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.Clear">
            <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            Items are retained front first.  
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.RetainAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection,
            taking multiplicities into account.
            Current implementation is not optimal.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equal to a given one.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Check">
            <summary>
            Check the integrity of the internal data structures of this array list.
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.HashedArrayList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True, indicating array list has bag semantics.</value>
        </member>
        <member name="P:C5.HashedArrayList`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.HashedArrayList`1.Add(`0)">
            <summary>
            Add an item to end of this list.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.HashedArrayList`1.C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.HashedArrayList`1.Count">
            <summary>
            
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="M:C5.HashedArrayList`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Dispose">
            <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
        </member>
        <member name="T:C5.SortedArray`1">
            <summary>
            A collection class implementing a sorted dynamic array data structure.
            </summary>
        </member>
        <member name="P:C5.SortedArray`1.ListenableEvents">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="M:C5.SortedArray`1.BinarySearch(`0,System.Int32@)">
            <summary>
            
            </summary>
            <param name="item">The item to search for</param>
            <param name="middle">The least index, middle, for which array[middle] >= item</param>
            <returns>True if item found</returns>
        </member>
        <member name="M:C5.SortedArray`1.#ctor">
            <summary>
            Create a dynamic sorted array with a natural comparer
            (and item equalityComparer,  assumed compatible)
            </summary>
            <exception cref="T:C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Int32)">
            <summary>
            Create a dynamic sorted array with a natural comparer 
            (and item equalityComparer,  assumed compatible)
            and prescribed initial capacity.
            </summary>
            <exception cref="T:C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
            <param name="capacity">The capacity</param>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a dynamic sorted array with an external comparer.
            <para>The itemequalityComparer will be compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1"/> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default"/>)
            is unlikely to be compatible with the external comparer. This makes the
            array inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)
            </para>
            </summary>
            <param name="comparer">The comparer</param>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a dynamic sorted array with an external comparer
            and prescribed initial capacity.
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1"/> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default"/>)
            is unlikely to be compatible with the external comparer. This makes the
            sorted array inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)
            </para>
            </summary>
            <param name="capacity">The capacity</param>
            <param name="comparer">The comparer</param>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a dynamic sorted array with an external comparer, an external item equalityComparer
            and prescribed initial capacity. This is the constructor to use if the collection 
            will be used as item in a hash table based collection.
            </summary>
            <param name="capacity">The capacity</param>
            <param name="comparer">The item comparer</param>
            <param name="equalityComparer">The item equalityComparer (assumed compatible)</param>
        </member>
        <member name="M:C5.SortedArray`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.SortedArray`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.SortedArray`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="f">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="m">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the sorted array,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.SortedArray`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the sorted array,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:C5.SortedArray`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the sorted array,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.SortedArray`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted array,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            <exception cref="T:C5.NoSuchItemException"/> if no such element exists (the
            supplied  value is less than the minimum of this collection.)
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decreasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.SortedArray`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.SortedArray`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.SortedArray`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="P:C5.SortedArray`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="M:C5.SortedArray`1.Clear">
            <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
        </member>
        <member name="M:C5.SortedArray`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent according to the
            itemequalityComparer) to a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was added (hence not found).</returns>
        </member>
        <member name="M:C5.SortedArray`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            it is implementation dependent if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedArray`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.SortedArray`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedArray`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.SortedArray`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. 
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.SortedArray`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. 
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.SortedArray`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            Multiplicities are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found (0 or 1).</returns>
        </member>
        <member name="M:C5.SortedArray`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedArray`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveAllCopies(`0)">
            <summary>
            Remove all (0 or 1) items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.SortedArray`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            Only available in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.SortedArray`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False since this collection has set semantics</value>
        </member>
        <member name="P:C5.SortedArray`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.SortedArray`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.SortedArray`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this collection if possible. 
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:C5.SortedArray`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.SortedArray`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="P:C5.SortedArray`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="P:C5.SortedArray`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:C5.SortedArray`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.SortedArray`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.SortedArray`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.SortedArray`1.C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="T:C5.EnumerableBase`1">
            <summary>
            A base class for implementing an IEnumerable&lt;T&gt;
            </summary>
        </member>
        <member name="M:C5.EnumerableBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.EnumerableBase`1.countItems(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Count the number of items in an enumerable by enumeration
            </summary>
            <param name="items">The enumerable to count</param>
            <returns>The size of the enumerable</returns>
        </member>
        <member name="T:C5.CollectionValueBase`1">
            <summary>
            Base class for classes implementing ICollectionValue[T]
            </summary>
        </member>
        <member name="P:C5.CollectionValueBase`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.CollectionValueBase`1.ActiveEvents">
            <summary>
            A flag bitmap of the events currently subscribed to by this collection.
            </summary>
            <value></value>
        </member>
        <member name="E:C5.CollectionValueBase`1.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseCollectionChanged">
            <summary>
            Fire the CollectionChanged event
            </summary>
        </member>
        <member name="E:C5.CollectionValueBase`1.CollectionCleared">
            <summary>
            The clear event. Will be raised for every Clear operation on the collection.
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseCollectionCleared(System.Boolean,System.Int32)">
            <summary>
            Fire the CollectionCleared event
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseCollectionCleared(System.Boolean,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Fire the CollectionCleared event
            </summary>
        </member>
        <member name="E:C5.CollectionValueBase`1.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseItemsAdded(`0,System.Int32)">
            <summary>
            Fire the ItemsAdded event
            </summary>
            <param name="item">The item that was added</param>
            <param name="count"></param>
        </member>
        <member name="E:C5.CollectionValueBase`1.ItemsRemoved">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseItemsRemoved(`0,System.Int32)">
            <summary>
            Fire the ItemsRemoved event
            </summary>
            <param name="item">The item that was removed</param>
            <param name="count"></param>
        </member>
        <member name="E:C5.CollectionValueBase`1.ItemInserted">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseItemInserted(`0,System.Int32)">
            <summary>
            Fire the ItemInserted event
            </summary>
            <param name="item">The item that was added</param>
            <param name="index"></param>
        </member>
        <member name="E:C5.CollectionValueBase`1.ItemRemovedAt">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseItemRemovedAt(`0,System.Int32)">
            <summary> 
            Fire the ItemRemovedAt event
            </summary>
            <param name="item">The item that was removed</param>
            <param name="index"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForSetThis(System.Int32,`0,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForInsert(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForRemove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForRemove(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForRemoveAt(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForUpdate(`0,`0)">
            <summary>
            
            </summary>
            <param name="newitem"></param>
            <param name="olditem"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForUpdate(`0,`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="newitem"></param>
            <param name="olditem"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForAdd(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.raiseForRemoveAll(C5.ICollectionValue{`0})">
            <summary>
            
            </summary>
            <param name="wasRemoved"></param>
        </member>
        <member name="T:C5.CollectionValueBase`1.RaiseForRemoveAllHandler">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.RaiseForRemoveAllHandler.#ctor(C5.CollectionValueBase{`0})">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="F:C5.CollectionValueBase`1.RaiseForRemoveAllHandler.MustFire">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.CollectionValueBase`1.RaiseForRemoveAllHandler.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.CollectionValueBase`1.RaiseForRemoveAllHandler.Raise">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.CollectionValueBase`1.IsEmpty">
            <summary>
            Check if collection is empty.
            </summary>
            <value>True if empty</value>
        </member>
        <member name="P:C5.CollectionValueBase`1.Count">
            <summary>
            The number of items in this collection.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.CollectionValueBase`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:C5.CollectionValueBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to part of an array.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if <code>index</code> 
            is not a valid index
            into the array (i.e. negative or greater than the size of the array)
            or the array does not have room for the items.</exception>
            <param name="array">The array to copy to.</param>
            <param name="index">The starting index.</param>
        </member>
        <member name="M:C5.CollectionValueBase`1.ToArray">
            <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.Apply(System.Action{`0})">
            <summary>
            Apply an single argument action, <see cref="T:Action`1"/> to this enumerable
            </summary>
            <param name="action">The action delegate</param>
        </member>
        <member name="M:C5.CollectionValueBase`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R = bool</code>) 
            defining the predicate</param>
            <returns>True if such an item exists</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.Find(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.All(System.Func{`0,System.Boolean})">
            <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R = bool</code>) 
            defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R = bool</code>) 
            defining the predicate</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.DirectedCollectionValueBase`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:C5.DirectedCollectionValueBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:C5.DirectedCollectionValueBase`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.DirectedCollectionValueBase`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="T:C5.CollectionBase`1">
            <summary>
            Base class (abstract) for ICollection implementations.
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.isReadOnlyBase">
            <summary>
            The underlying field of the ReadOnly property
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.stamp">
            <summary>
            The current stamp value
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.size">
            <summary>
            The number of items in the collection
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.itemequalityComparer">
            <summary>
            The item equalityComparer of the collection
            </summary>
        </member>
        <member name="M:C5.CollectionBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="itemequalityComparer"></param>
        </member>
        <member name="M:C5.CollectionBase`1.checkRange(System.Int32,System.Int32)">
            <summary>
            Utility method for range checking.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative or
             if the range does not fit within collection size.</exception>
            <param name="start">start of range</param>
            <param name="count">size of range</param>
        </member>
        <member name="M:C5.CollectionBase`1.ComputeHashCode(C5.ICollectionValue{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Compute the unsequenced hash code of a collection
            </summary>
            <param name="items">The collection to compute hash code for</param>
            <param name="itemequalityComparer">The item equalitySCG.Comparer</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.CollectionBase`1.StaticEquals(C5.ICollection{`0},C5.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Examine if collection1 and collection2 are equal as unsequenced collections
            using the specified item equalityComparer (assumed compatible with the two collections).
            </summary>
            <param name="collection1">The first collection</param>
            <param name="collection2">The second collection</param>
            <param name="itemequalityComparer">The item equalityComparer to use for comparison</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:C5.CollectionBase`1.GetUnsequencedHashCode">
            <summary>
            Get the unsequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.CollectionBase`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            Check if the contents of otherCollection is equal to the contents of this
            in the unsequenced sense.  Uses the item equality comparer of this collection
            </summary>
            <param name="otherCollection">The collection to compare to.</param>
            <returns>True if  equal</returns>
        </member>
        <member name="M:C5.CollectionBase`1.modifycheck(System.Int32)">
            <summary>
            Check if the collection has been modified since a specified time, expressed as a stamp value.
            </summary>
            <exception cref="T:C5.CollectionModifiedException"> if this collection has been updated 
            since a target time</exception>
            <param name="thestamp">The stamp identifying the target time</param>
        </member>
        <member name="M:C5.CollectionBase`1.updatecheck">
            <summary>
            Check if it is valid to perform update operations, and if so increment stamp.
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException">If collection is read-only</exception>
        </member>
        <member name="P:C5.CollectionBase`1.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if this collection is read only</value>
        </member>
        <member name="P:C5.CollectionBase`1.Count">
            <summary>
            
            </summary>
            <value>The size of this collection</value>
        </member>
        <member name="P:C5.CollectionBase`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="P:C5.CollectionBase`1.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.CollectionBase`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty</value>
        </member>
        <member name="M:C5.CollectionBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="T:C5.DirectedCollectionBase`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:C5.DirectedCollectionBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="itemequalityComparer"></param>
        </member>
        <member name="P:C5.DirectedCollectionBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:C5.DirectedCollectionBase`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.DirectedCollectionBase`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="T:C5.SequencedBase`1">
            <summary>
            Base class (abstract) for sequenced collection implementations.
            </summary>
        </member>
        <member name="M:C5.SequencedBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="itemequalityComparer"></param>
        </member>
        <member name="M:C5.SequencedBase`1.ComputeHashCode(C5.ISequenced{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Compute the unsequenced hash code of a collection
            </summary>
            <param name="items">The collection to compute hash code for</param>
            <param name="itemequalityComparer">The item equalitySCG.Comparer</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.SequencedBase`1.StaticEquals(C5.ISequenced{`0},C5.ISequenced{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Examine if tit and tat are equal as sequenced collections
            using the specified item equalityComparer (assumed compatible with the two collections).
            </summary>
            <param name="collection1">The first collection</param>
            <param name="collection2">The second collection</param>
            <param name="itemequalityComparer">The item equalityComparer to use for comparison</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:C5.SequencedBase`1.GetSequencedHashCode">
            <summary>
            Get the sequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.SequencedBase`1.SequencedEquals(C5.ISequenced{`0})">
            <summary>
            Check if the contents of that is equal to the contents of this
            in the sequenced sense. Using the item equalityComparer of this collection.
            </summary>
            <param name="otherCollection">The collection to compare to.</param>
            <returns>True if  equal</returns>
        </member>
        <member name="M:C5.SequencedBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.SequencedBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:C5.SequencedBase`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
            <param name="predicate">A delegate defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:C5.SequencedBase`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
            <param name="predicate">A delegate defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="T:C5.ArrayBase`1">
            <summary>
            Base class for collection classes of dynamic array type implementations.
            </summary>
        </member>
        <member name="F:C5.ArrayBase`1.array">
            <summary>
            The actual internal array container. Will be extended on demand.
            </summary>
        </member>
        <member name="F:C5.ArrayBase`1.offsetField">
            <summary>
            The offset into the internal array container of the first item. The offset is 0 for a 
            base dynamic array and may be positive for an updatable view into a base dynamic array.
            </summary>
        </member>
        <member name="M:C5.ArrayBase`1.expand">
            <summary>
            Double the size of the internal array.
            </summary>
        </member>
        <member name="M:C5.ArrayBase`1.expand(System.Int32,System.Int32)">
            <summary>
            Expand the internal array container.
            </summary>
            <param name="newcapacity">The new size of the internal array - 
            will be rounded upwards to a power of 2.</param>
            <param name="newsize">The (new) size of the (base) collection.</param>
        </member>
        <member name="M:C5.ArrayBase`1.InsertProtected(System.Int32,`0)">
            <summary>
            Insert an item at a specific index, moving items to the right
            upwards and expanding the array if necessary.
            </summary>
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayBase`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an empty ArrayBase object.
            </summary>
            <param name="capacity">The initial capacity of the internal array container.
            Will be rounded upwards to the nearest power of 2 greater than or equal to 8.</param>
            <param name="itemequalityComparer">The item equalityComparer to use, primarily for item equality</param>
        </member>
        <member name="P:C5.ArrayBase`1.Item(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If the arguments does not describe a 
            valid range in the indexed collection, cf. <see cref="M:C5.CollectionBase`1.checkRange(System.Int32,System.Int32)"/>.</exception>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="M:C5.ArrayBase`1.Clear">
            <summary>
            Remove all items and reset size of internal array container.
            </summary>
        </member>
        <member name="M:C5.ArrayBase`1.ToArray">
            <summary>
            Create an array containing (copies) of the items of this collection in enumeration order.
            </summary>
            <returns>The new array</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Check">
            <summary>
            Perform an internal consistency (invariant) test on the array base.
            </summary>
            <returns>True if test succeeds.</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Backwards">
            <summary>
            Create a directed collection with the same contents as this one, but 
            opposite enumeration sequence.
            </summary>
            <returns>The mirrored collection.</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Choose">
            <summary>
            Choose some item of this collection. The result is the last item in the internal array,
            making it efficient to remove.
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this array based collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="T:C5.ArrayBase`1.Range">
            <summary>
            A helper class for defining results of interval queries on array based collections.
            </summary>
        </member>
        <member name="P:C5.ArrayBase`1.Range.IsEmpty">
            <summary>
            
            </summary>
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:C5.ArrayBase`1.Range.Count">
            <summary>
            
            </summary>
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <value>The number of items in the range</value>
        </member>
        <member name="P:C5.ArrayBase`1.Range.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:C5.ArrayBase`1.Range.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <exception cref="T:C5.NoSuchItemException">if range is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.ArrayBase`1.Range.GetEnumerator">
            <summary>
            Create an enumerator for this range of an array based collection.
            </summary>
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Range.Backwards">
            <summary>
            Create an array collection range with the same contents as this one, but 
            opposite enumeration sequence.
            </summary>
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <returns>The mirrored collection.</returns>
        </member>
        <member name="P:C5.ArrayBase`1.Range.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <exception cref="T:C5.CollectionModifiedException">if underlying collection has been modified.</exception>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.ComparerFactory`1">
            <summary>
            Factory class to create comparers and equality comparers using Func delegates
            </summary>
            <typeparam name="T">The type to compare</typeparam>
        </member>
        <member name="M:C5.ComparerFactory`1.CreateComparer(System.Func{`0,`0,System.Int32})">
            <summary>
            Create a new comparer.
            </summary>
            <param name="comparer">The compare function.</param>
            <returns>The comparer</returns>
        </member>
        <member name="M:C5.ComparerFactory`1.CreateEqualityComparer(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Creates a new equality comparer.
            </summary>
            <param name="equals">The equals function.</param>
            <param name="getHashCode">The getHashCode function.</param>
            <returns>The equality comparer.</returns>
        </member>
        <member name="T:C5.EqualityComparer`1">
            <summary>
            Utility class for building default generic equality comparers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:C5.EqualityComparer`1.Default">
            <summary>
            A default generic equality comparer for type T. The procedure is as follows:
            <list>
            <item>If the actual generic argument T implements the generic interface
            <see cref="T:C5.ISequenced`1"/> for some value W of its generic parameter T,
            the equalityComparer will be <see cref="T:C5.SequencedCollectionEqualityComparer`2"/></item>
            <item>If the actual generic argument T implements
            <see cref="T:C5.ICollection`1"/> for some value W of its generic parameter T,
            the equalityComparer will be <see cref="T:C5.UnsequencedCollectionEqualityComparer`2"/></item>
            <item>Otherwise the SCG.EqualityComparer&lt;T&gt;.Default is returned</item>
            </list>
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:C5.InternalComparer`1">
            <summary>
            Defines a method that a type implements to compare two objects.
            This class is intentionally declared internal - use the ComparerFactory to create an instance.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:C5.InternalComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Constructs a comparer using one Func delegate.
            </summary>
            <param name="compare">The compare function.</param>
        </member>
        <member name="M:C5.InternalComparer`1.Compare(`0,`0)">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>A signed integer that indicates the relative values of x and y, as shown in the following table. Value Condition Less than zero x is less than y. Zero x equals y. Greater than zero x is greater than y.</returns>
        </member>
        <member name="T:C5.InternalEqualityComparer`1">
            <summary>
            Defines methods to support the comparison of objects for equality.
            This class is intentionally declared internal - use the ComparerFactory to create an instance.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:C5.InternalEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Constructs and equality comparer using two Func delegates.
            </summary>
            <param name="equals">The equals function.</param>
            <param name="getHashCode">The get hash code function.</param>
        </member>
        <member name="M:C5.InternalEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type T to compare.</param>
            <param name="y">The second object of type T to compare.</param>
            <returns>true if the specified objects are equal; otherwise, false.</returns>
        </member>
        <member name="M:C5.InternalEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <param name="obj">The System.Object for which a hash code is to be returned.</param>
            <returns>A hash code for the specified object.</returns>
        </member>
        <member name="T:C5.Debug">
            <summary>
            Class containing debugging symbols - to eliminate preprocessor directives
            </summary>
        </member>
        <member name="P:C5.Debug.UseDeterministicHashing">
            <summary>
            Flag used to test hashing. Set to true when unit testing hash functions.
            </summary>
        </member>
        <member name="T:C5.KeyValuePair`2">
            <summary>
            An entry in a dictionary from K to V.
            </summary>
        </member>
        <member name="F:C5.KeyValuePair`2.Key">
            <summary>
            The key field of the entry
            </summary>
        </member>
        <member name="F:C5.KeyValuePair`2.Value">
            <summary>
            The value field of the entry
            </summary>
        </member>
        <member name="M:C5.KeyValuePair`2.#ctor(`0,`1)">
            <summary>
            Create an entry with specified key and value
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
        </member>
        <member name="M:C5.KeyValuePair`2.#ctor(`0)">
            <summary>
            Create an entry with a specified key. The value will be the default value of type <code>V</code>.
            </summary>
            <param name="key">The key</param>
        </member>
        <member name="M:C5.KeyValuePair`2.ToString">
            <summary>
            Pretty print an entry
            </summary>
            <returns>(key, value)</returns>
        </member>
        <member name="M:C5.KeyValuePair`2.Equals(System.Object)">
            <summary>
            Check equality of entries. 
            </summary>
            <param name="obj">The other object</param>
            <returns>True if obj is an entry of the same type and has the same key and value</returns>
        </member>
        <member name="M:C5.KeyValuePair`2.GetHashCode">
            <summary>
            Get the hash code of the pair.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.KeyValuePair`2.Equals(C5.KeyValuePair{`0,`1})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:C5.KeyValuePair`2.op_Equality(C5.KeyValuePair{`0,`1},C5.KeyValuePair{`0,`1})">
            <summary>
            
            </summary>
            <param name="pair1"></param>
            <param name="pair2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.KeyValuePair`2.op_Inequality(C5.KeyValuePair{`0,`1},C5.KeyValuePair{`0,`1})">
            <summary>
            
            </summary>
            <param name="pair1"></param>
            <param name="pair2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.KeyValuePair`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="formatProvider"></param>
            <param name="rest"></param>
            <returns></returns>
        </member>
        <member name="M:C5.KeyValuePair`2.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.KeyValuePairComparer`2">
            <summary>
            Default comparer for dictionary entries in a sorted dictionary.
            Entry comparisons only look at keys and uses an externally defined comparer for that.
            </summary>
        </member>
        <member name="M:C5.KeyValuePairComparer`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create an entry comparer for a item comparer of the keys
            </summary>
            <param name="comparer">Comparer of keys</param>
        </member>
        <member name="M:C5.KeyValuePairComparer`2.Compare(C5.KeyValuePair{`0,`1},C5.KeyValuePair{`0,`1})">
            <summary>
            Compare two entries
            </summary>
            <param name="entry1">First entry</param>
            <param name="entry2">Second entry</param>
            <returns>The result of comparing the keys</returns>
        </member>
        <member name="T:C5.KeyValuePairEqualityComparer`2">
            <summary>
            Default equalityComparer for dictionary entries.
            Operations only look at keys and uses an externally defined equalityComparer for that.
            </summary>
        </member>
        <member name="M:C5.KeyValuePairEqualityComparer`2.#ctor">
            <summary>
            Create an entry equalityComparer using the default equalityComparer for keys
            </summary>
        </member>
        <member name="M:C5.KeyValuePairEqualityComparer`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an entry equalityComparer from a specified item equalityComparer for the keys
            </summary>
            <param name="keyequalityComparer">The key equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.KeyValuePairEqualityComparer`2.GetHashCode(C5.KeyValuePair{`0,`1})">
            <summary>
            Get the hash code of the entry
            </summary>
            <param name="entry">The entry</param>
            <returns>The hash code of the key</returns>
        </member>
        <member name="M:C5.KeyValuePairEqualityComparer`2.Equals(C5.KeyValuePair{`0,`1},C5.KeyValuePair{`0,`1})">
            <summary>
            Test two entries for equality
            </summary>
            <param name="entry1">First entry</param>
            <param name="entry2">Second entry</param>
            <returns>True if keys are equal</returns>
        </member>
        <member name="T:C5.DictionaryBase`2">
            <summary>
            A base class for implementing a dictionary based on a set collection implementation.
            <i>See the source code for <see cref="T:C5.HashDictionary`2"/> for an example</i>
            
            </summary>
        </member>
        <member name="F:C5.DictionaryBase`2.pairs">
            <summary>
            The set collection of entries underlying this dictionary implementation
            </summary>
        </member>
        <member name="E:C5.DictionaryBase`2.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:C5.DictionaryBase`2.CollectionCleared">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:C5.DictionaryBase`2.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="E:C5.DictionaryBase`2.ItemsRemoved">
            <summary>
            The item added  event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="P:C5.DictionaryBase`2.ListenableEvents">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.DictionaryBase`2.ActiveEvents">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.DictionaryBase`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="keyequalityComparer"></param>
        </member>
        <member name="P:C5.DictionaryBase`2.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.DictionaryBase`2.Add(`0,`1)">
            <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException"> if there already is an entry with the same key. </exception>
            <param name="key">Key to add</param>
            <param name="value">Value to add</param>
        </member>
        <member name="M:C5.DictionaryBase`2.AddAll``2(System.Collections.Generic.IEnumerable{C5.KeyValuePair{``0,``1}})">
            <summary>
            Add the entries from a collection of <see cref="T:C5.KeyValuePair`2"/> pairs to this dictionary.
            <para><b>TODO: add restrictions L:K and W:V when the .Net SDK allows it </b></para>
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException"> 
            If the input contains duplicate keys or a key already present in this dictionary.</exception>
            <param name="entries"></param>
        </member>
        <member name="M:C5.DictionaryBase`2.Remove(`0)">
            <summary>
            Remove an entry with a given key from the dictionary
            </summary>
            <param name="key">The key of the entry to remove</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Remove(`0,`1@)">
            <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
            <param name="key">The key of the entry to remove</param>
            <param name="value">On exit, the value of the removed entry</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Clear">
            <summary>
            Remove all entries from the dictionary
            </summary>
        </member>
        <member name="P:C5.DictionaryBase`2.ContainsSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.DictionaryBase`2.Contains(`0)">
            <summary>
            Check if there is an entry with a specified key
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Find(`0@,`1@)">
            <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
            <param name="key">The key to look for</param>
            <param name="value">On exit, the value of the entry</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Update(`0,`1)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
            <param name="key">The key to look for</param>
            <param name="value">The new value</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Update(`0,`1,`1@)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="oldvalue"></param>
            <returns></returns>
        </member>
        <member name="M:C5.DictionaryBase`2.FindOrAdd(`0,`1@)">
            <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
            <param name="key">On entry the key to look for</param>
            <param name="value">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.UpdateOrAdd(`0,`1)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="value">The value to add or replace with.</param>
            <returns>True if entry was updated.</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.UpdateOrAdd(`0,`1,`1@)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found and the old value if any.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="oldvalue"></param>
            <returns></returns>
        </member>
        <member name="P:C5.DictionaryBase`2.Keys">
            <summary>
            
            </summary>
            <value>A collection containing all the keys of the dictionary</value>
        </member>
        <member name="P:C5.DictionaryBase`2.Values">
            <summary>
            
            </summary>
            <value>A collection containing all the values of the dictionary</value>
        </member>
        <member name="P:C5.DictionaryBase`2.Func">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.DictionaryBase`2.Item(`0)">
            <summary>
            Indexer by key for dictionary. 
            <para>The get method will throw an exception if no entry is found. </para>
            <para>The set method behaves like <see cref="M:C5.DictionaryBase`2.UpdateOrAdd(`0,`1)"/>.</para>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> On get if no entry is found. </exception>
            <value>The value corresponding to the key</value>
        </member>
        <member name="P:C5.DictionaryBase`2.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if dictionary is read  only</value>
        </member>
        <member name="M:C5.DictionaryBase`2.Check">
            <summary>
            Check the integrity of the internal data structures of this dictionary.
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.DictionaryBase`2.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:C5.DictionaryBase`2.Count">
            <summary>
            
            </summary>
            <value>The number of entries in the dictionary</value>
        </member>
        <member name="P:C5.DictionaryBase`2.CountSpeed">
            <summary>
            
            </summary>
            <value>The number of entries in the dictionary</value>
        </member>
        <member name="M:C5.DictionaryBase`2.Choose">
            <summary>
            Choose some entry in this Dictionary. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.DictionaryBase`2.GetEnumerator">
            <summary>
            Create an enumerator for the collection of entries of the dictionary
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.SortedDictionaryBase`2">
            <summary>
            A base class for implementing a sorted dictionary based on a sorted set collection implementation.
            <i>See the source code for <see cref="T:C5.TreeDictionary`2"/> for an example</i>
            
            </summary>
        </member>
        <member name="F:C5.SortedDictionaryBase`2.sortedpairs">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="keycomparer"></param>
            <param name="keyequalityComparer"></param>
        </member>
        <member name="P:C5.SortedDictionaryBase`2.Comparer">
            <summary>
            The key comparer used by this dictionary.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.SortedDictionaryBase`2.Keys">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.TryPredecessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a predecessor</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.TrySuccessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The successor, if any</param>
            <returns>True if the key has a successor</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.TryWeakPredecessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a weak predecessor</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.TryWeakSuccessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The weak successor, if any</param>
            <returns>True if the key has a weak successor</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.Predecessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.Successor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.WeakPredecessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.WeakSuccessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.FindMin">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.DeleteMin">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.FindMax">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.DeleteMax">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.Cut(System.IComparable{`0},C5.KeyValuePair{`0,`1}@,System.Boolean@,C5.KeyValuePair{`0,`1}@,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="cutter"></param>
            <param name="lowEntry"></param>
            <param name="lowIsValid"></param>
            <param name="highEntry"></param>
            <param name="highIsValid"></param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RangeFrom(`0)">
            <summary>
            
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RangeFromTo(`0,`0)">
            <summary>
            
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RangeTo(`0)">
            <summary>
            
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RangeAll">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.AddSorted(System.Collections.Generic.IEnumerable{C5.KeyValuePair{`0,`1}})">
            <summary>
            
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RemoveRangeFrom(`0)">
            <summary>
            
            </summary>
            <param name="lowKey"></param>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RemoveRangeFromTo(`0,`0)">
            <summary>
            
            </summary>
            <param name="lowKey"></param>
            <param name="highKey"></param>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.RemoveRangeTo(`0)">
            <summary>
            
            </summary>
            <param name="highKey"></param>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.SortedKeysCollection.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.SortedKeysCollection.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.SortedDictionaryBase`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.KeyValuePair">
            <summary>
            Static class to allow creation of KeyValuePair using type inference
            </summary>
        </member>
        <member name="M:C5.KeyValuePair.Create``2(``0,``1)">
            <summary>
            Create an instance of the KeyValuePair using type inference.
            </summary>
        </member>
        <member name="M:C5.SortedArrayDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a red-black tree dictionary using an external comparer for keys.
            </summary>
            <param name="comparer">The external comparer</param>
        </member>
        <member name="M:C5.SortedArrayDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="comparer"></param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:C5.SortedArrayDictionary`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="comparer"></param>
            <param name="equalityComparer"></param>
            <param name="capacity"></param>
        </member>
        <member name="T:C5.Speed">
            <summary>
            The symbolic characterization of the speed of lookups for a collection.
            The values may refer to worst-case, amortized and/or expected asymtotic 
            complexity wrt. the collection size.
            </summary>
        </member>
        <member name="F:C5.Speed.PotentiallyInfinite">
            <summary>
            Counting the collection with the <code>Count property</code> may not return
            (for a synthetic and potentially infinite collection).
            </summary>
        </member>
        <member name="F:C5.Speed.Linear">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property may take time O(n),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="F:C5.Speed.Log">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(log n),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="F:C5.Speed.Constant">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(1),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="T:C5.EnumerationDirection">
            <summary>
            Direction of enumeration order relative to original collection.
            </summary>
        </member>
        <member name="F:C5.EnumerationDirection.Forwards">
            <summary>
            Same direction
            </summary>
        </member>
        <member name="F:C5.EnumerationDirection.Backwards">
            <summary>
            Opposite direction
            </summary>
        </member>
        <member name="T:C5.EventTypeEnum">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.Changed">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.Cleared">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.Added">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.Removed">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.Basic">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.Inserted">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.RemovedAt">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.EventTypeEnum.All">
            <summary>
            
            </summary>
        </member>
        <member name="T:C5.EventBlock`1">
            <summary>
            Holds the real events for a collection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:C5.ProxyEventBlock`1">
            <summary>
            Tentative, to conserve memory in GuardedCollectionValueBase
            This should really be nested in Guarded collection value, only have a guardereal field
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:C5.ItemAtEventArgs`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:C5.ItemAtEventArgs`1.Item">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.ItemAtEventArgs`1.Index">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.ItemAtEventArgs`1.#ctor(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="index"></param>
        </member>
        <member name="M:C5.ItemAtEventArgs`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.ItemCountEventArgs`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:C5.ItemCountEventArgs`1.Item">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.ItemCountEventArgs`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.ItemCountEventArgs`1.#ctor(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.ItemCountEventArgs`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.ClearedEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.ClearedEventArgs.Full">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.ClearedEventArgs.Count">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.ClearedEventArgs.#ctor(System.Boolean,System.Int32)">
            <summary>
            
            </summary>
            
            <param name="full">True if the operation cleared all of the collection</param>
            <param name="count">The number of items removed by the clear.</param>
        </member>
        <member name="M:C5.ClearedEventArgs.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.ClearedRangeEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.ClearedRangeEventArgs.Start">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.ClearedRangeEventArgs.#ctor(System.Boolean,System.Int32,System.Nullable{System.Int32})">
            <summary>
            
            </summary>
            <param name="full"></param>
            <param name="count"></param>
            <param name="start"></param>
        </member>
        <member name="M:C5.ClearedRangeEventArgs.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.CollectionChangedHandler`1">
            <summary>
            The type of event raised after an operation on a collection has changed its contents.
            Normally, a multioperation like AddAll, 
            <see cref="M:C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})"/> 
            will only fire one CollectionChanged event. Any operation that changes the collection
            must fire CollectionChanged as its last event.
            </summary>
        </member>
        <member name="T:C5.CollectionClearedHandler`1">
            <summary>
            The type of event raised after the Clear() operation on a collection.
            <para/>
            Note: The Clear() operation will not fire ItemsRemoved events. 
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:C5.ItemsAddedHandler`1">
            <summary>
            The type of event raised after an item has been added to a collection.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: an Update operation will fire an ItemsRemoved and an ItemsAdded event.
            <para/>
            Note: When an item is inserted into a list (<see cref="T:C5.IList`1"/>), both
            ItemInserted and ItemsAdded events will be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs">An object with the item that was added</param>
        </member>
        <member name="T:C5.ItemsRemovedHandler`1">
            <summary>
            The type of event raised after an item has been removed from a collection.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: The Clear() operation will not fire ItemsRemoved events. 
            <para/>
            Note: an Update operation will fire an ItemsRemoved and an ItemsAdded event.
            <para/>
            Note: When an item is removed from a list by the RemoveAt operation, both an 
            ItemsRemoved and an ItemRemovedAt event will be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs">An object with the item that was removed</param>
        </member>
        <member name="T:C5.ItemInsertedHandler`1">
            <summary>
            The type of event raised after an item has been inserted into a list by an Insert, 
            InsertFirst or InsertLast operation.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: an ItemsAdded event will also be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:C5.ItemRemovedAtHandler`1">
            <summary>
            The type of event raised after an item has been removed from a list by a RemoveAt(int i)
            operation (or RemoveFirst(), RemoveLast(), Remove() operation).
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: an ItemRemoved event will also be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:C5.InternalException">
            <summary>
            An exception to throw from library code when an internal inconsistency is encountered.
            </summary>
        </member>
        <member name="T:C5.ReadOnlyCollectionException">
            <summary>
            An exception thrown by an update operation on a Read-Only collection or dictionary.
            <para>This exception will be thrown unconditionally when an update operation 
            (method or set property) is called. No check is made to see if the update operation, 
            if allowed, would actually change the collection. </para>
            </summary>
        </member>
        <member name="M:C5.ReadOnlyCollectionException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.ReadOnlyCollectionException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.FixedSizeCollectionException">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.FixedSizeCollectionException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.FixedSizeCollectionException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.UnlistenableEventException">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.UnlistenableEventException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.UnlistenableEventException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.CollectionModifiedException">
            <summary>
            An exception thrown by enumerators, range views etc. when accessed after 
            the underlying collection has been modified.
            </summary>
        </member>
        <member name="M:C5.CollectionModifiedException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.CollectionModifiedException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.ViewDisposedException">
            <summary>
            An exception thrown when trying to access a view (a list view on a <see cref="T:C5.IList`1"/> or 
            a snapshot on a <see cref="T:C5.IPersistentSorted`1"/>)
            that has been invalidated by some earlier operation.
            <para>
            The typical scenario is a view on a list that hash been invalidated by a call to 
            Sort, Reverse or Shuffle on some other, overlapping view or the whole list.
            </para>
            </summary>
        </member>
        <member name="M:C5.ViewDisposedException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.ViewDisposedException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.NoSuchItemException">
            <summary>
            An exception thrown by a lookup or lookup with update operation that does not 
            find the lookup item and has no other means to communicate failure.
            <para>The typical scenario is a lookup by key in a dictionary with an indexer,
            see e.g. <see cref="P:C5.IDictionary`2.Item(`0)"/></para>
            </summary>
        </member>
        <member name="M:C5.NoSuchItemException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.NoSuchItemException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.NotAViewException">
            <summary>
            An exception thrown by an operation on a list (<see cref="T:C5.IList`1"/>)
            that only makes sense for a view, not for an underlying list.
            </summary>
        </member>
        <member name="M:C5.NotAViewException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.NotAViewException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.DuplicateNotAllowedException">
            <summary>
            An exception thrown when an operation attempts to create a duplicate in a collection with set semantics 
            (<see cref="P:C5.IExtensible`1.AllowsDuplicates"/> is false) or attempts to create a duplicate key in a dictionary.
            <para>With collections this can only happen with Insert operations on lists, since the Add operations will
            not try to create duplictes and either ignore the failure or report it in a bool return value.
            </para>
            <para>With dictionaries this can happen with the <see cref="M:C5.IDictionary`2.Add(`0,`1)"/> metod.</para>
            </summary>
        </member>
        <member name="M:C5.DuplicateNotAllowedException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.DuplicateNotAllowedException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.InvalidPriorityQueueHandleException">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.InvalidPriorityQueueHandleException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.InvalidPriorityQueueHandleException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.NotComparableException">
            <summary>
            An exception thrown by an operation that need to construct a natural
            comparer for a type.
            </summary>
        </member>
        <member name="M:C5.NotComparableException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.NotComparableException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.IncompatibleViewException">
            <summary>
            An exception thrown by operations on a list that expects an argument
            that is a view on the same underlying list.
            </summary>
        </member>
        <member name="M:C5.IncompatibleViewException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:C5.IncompatibleViewException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:C5.IShowable">
            <summary>
            <i>(Describe usage of "L:300" format string.)</i>
            </summary>
        </member>
        <member name="M:C5.IShowable.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            Format <code>this</code> using at most approximately <code>rest</code> chars and 
            append the result, possibly truncated, to stringbuilder.
            Subtract the actual number of used chars from <code>rest</code>.
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns>True if the appended formatted string was complete (not truncated).</returns>
        </member>
        <member name="T:C5.Showing">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.Showing.Show(System.Object,System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            Show  <code>Object obj</code> by appending it to <code>stringbuilder</code>
            </summary>
            <param name="obj"></param>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns>True if <code>obj</code> was shown completely.</returns>
        </member>
        <member name="M:C5.Showing.ShowString(C5.IShowable,System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="showable"></param>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Showing.maxLength(System.String)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Showing.ShowCollectionValue``1(C5.ICollectionValue{``0},System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns>True if collection was shown completely</returns>
        </member>
        <member name="M:C5.Showing.ShowDictionary``2(C5.IDictionary{``0,``1},System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            
            <param name="dictionary"></param>
            <param name="stringbuilder"></param>
            <param name="formatProvider"></param>
            <param name="rest"></param>
            <returns></returns>
        </member>
        <member name="T:C5.ComparerZeroHashCodeEqualityComparer`1">
            <summary>
            An equalityComparer compatible with a given comparer. All hash codes are 0, 
            meaning that anything based on hash codes will be quite inefficient.
            <para><b>Note: this will give a new EqualityComparer each time created!</b></para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:C5.ComparerZeroHashCodeEqualityComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a trivial <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> compatible with the 
            <see cref="T:System.Collections.Generic.IComparer`1"/> <code>comparer</code>
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:C5.ComparerZeroHashCodeEqualityComparer`1.GetHashCode(`0)">
            <summary>
            A trivial, inefficient hash function. Compatible with any equality relation.
            </summary>
            <param name="item"></param>
            <returns>0</returns>
        </member>
        <member name="M:C5.ComparerZeroHashCodeEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Equality of two items as defined by the comparer.
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="T:C5.SequencedCollectionEqualityComparer`2">
            <summary>
            Prototype for a sequenced equalityComparer for something (T) that implements ISequenced[W].
            This will use ISequenced[W] specific implementations of the equality comparer operations.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="W"></typeparam>
        </member>
        <member name="P:C5.SequencedCollectionEqualityComparer`2.Default">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.SequencedCollectionEqualityComparer`2.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this sequenced equalityComparer
            </summary>
            <param name="collection">The collection</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.SequencedCollectionEqualityComparer`2.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this sequenced equalityComparer
            </summary>
            <param name="collection1">first collection</param>
            <param name="collection2">second collection</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.UnsequencedCollectionEqualityComparer`2">
            <summary>
            Prototype for an unsequenced equalityComparer for something (T) that implements ICollection[W]
            This will use ICollection[W] specific implementations of the equalityComparer operations
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="W"></typeparam>
        </member>
        <member name="P:C5.UnsequencedCollectionEqualityComparer`2.Default">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.UnsequencedCollectionEqualityComparer`2.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this unsequenced equalityComparer
            </summary>
            <param name="collection">The collection</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.UnsequencedCollectionEqualityComparer`2.Equals(`0,`0)">
            <summary>
            Check if two collections are equal with respect to this unsequenced equalityComparer
            </summary>
            <param name="collection1">first collection</param>
            <param name="collection2">second collection</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.HashBag`1">
            <summary>
            A bag collection based on a hash table of (item,count) pairs. 
            </summary>
        </member>
        <member name="P:C5.HashBag`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashBag`1.#ctor">
            <summary>
            Create a hash bag with the default item equalityComparer.
            </summary>
        </member>
        <member name="M:C5.HashBag`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash bag with an external item equalityComparer.
            </summary>
            <param name="itemequalityComparer">The external item equalityComparer.</param>
        </member>
        <member name="M:C5.HashBag`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash bag with external item equalityComparer, prescribed initial table size and default fill threshold (66%)
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.HashBag`1.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash bag with external item equalityComparer, prescribed initial table size and fill threshold.
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="fill">Fill threshold (valid range 10% to 90%)</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="P:C5.HashBag`1.ContainsSpeed">
            <summary>
            The complexity of the Contains operation
            </summary>
            <value>Always returns Speed.Constant</value>
        </member>
        <member name="M:C5.HashBag`1.Contains(`0)">
            <summary>
            Check if an item is in the bag 
            </summary>
            <param name="item">The item to look for</param>
            <returns>True if bag contains item</returns>
        </member>
        <member name="M:C5.HashBag`1.Find(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the bag and
            if so report the actual item object found.
            </summary>
            <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
            <returns>True if bag contains item</returns>
        </member>
        <member name="M:C5.HashBag`1.Update(`0)">
            <summary>
            Check if an item (collection equal to a given one) is in the bag and
            if so replace the item object in the bag with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:C5.HashBag`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashBag`1.FindOrAdd(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the bag.
            If found, report the actual item object in the bag,
            else add the supplied one.
            </summary>
            <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
            <returns>True if item was found</returns>
        </member>
        <member name="M:C5.HashBag`1.UpdateOrAdd(`0)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the bag and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:C5.HashBag`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashBag`1.Remove(`0)">
            <summary>
            Remove one copy of an item from the bag
            </summary>
            <param name="item">The item to remove</param>
            <returns>True if item was (found and) removed </returns>
        </member>
        <member name="M:C5.HashBag`1.Remove(`0,`0@)">
            <summary>
            Remove one copy of an item from the bag, reporting the actual matching item object.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if item was found.</returns>
        </member>
        <member name="M:C5.HashBag`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a supplied collection from this bag, counting multiplicities.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashBag`1.Clear">
            <summary>
            Remove all items from the bag, resetting internal table to initial size.
            </summary>
        </member>
        <member name="M:C5.HashBag`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items *not* in a supplied collection from this bag,
            counting multiplicities.
            </summary>
            <param name="items">The items to retain</param>
        </member>
        <member name="M:C5.HashBag`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in a supplied collection is in this bag
            (counting multiplicities). 
            </summary>
            <param name="items">The items to look for.</param>
            <returns>True if all items are found.</returns>
        </member>
        <member name="M:C5.HashBag`1.ToArray">
            <summary>
            Create an array containing all items in this bag (in enumeration order).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.HashBag`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item is in this set.
            </summary>
            <param name="item">The item to look for.</param>
            <returns>The count</returns>
        </member>
        <member name="M:C5.HashBag`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashBag`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashBag`1.RemoveAllCopies(`0)">
            <summary>
            Remove all copies of item from this set.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:C5.HashBag`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this bag to part of an array.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if i is negative.
            <exception cref="T:System.ArgumentException"/> if the array does not have room for the items.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The starting index.</param>
        </member>
        <member name="P:C5.HashBag`1.AllowsDuplicates">
            <summary>
            Report if this is a set collection.
            </summary>
            <value>Always true</value>
        </member>
        <member name="P:C5.HashBag`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.HashBag`1.Add(`0)">
            <summary>
            Add an item to this bag.
            </summary>
            <param name="item">The item to add.</param>
            <returns>Always true</returns>
        </member>
        <member name="M:C5.HashBag`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this bag.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:C5.HashBag`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashBag`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.HashBag`1.GetEnumerator">
            <summary>
            Create an enumerator for this bag.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.HashBag`1.Check">
            <summary>
            Test internal structure of data (invariants)
            </summary>
            <returns>True if pass</returns>
        </member>
        <member name="T:C5.HashDictionary`2">
            <summary>
            A generic dictionary class based on a hash set class <see cref="T:C5.HashSet`1"/>. 
            </summary>
        </member>
        <member name="M:C5.HashDictionary`2.#ctor">
            <summary>
            Create a hash dictionary using a default equalityComparer for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
        </member>
        <member name="M:C5.HashDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash dictionary using a custom equalityComparer for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
            <param name="keyequalityComparer">The external key equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.HashDictionary`2.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash dictionary using a custom equalityComparer and prescribing the 
            initial size of the dictionary and a non-default threshold for internal table expansion.
            </summary>
            <param name="capacity">The initial capacity. Will be rounded upwards to nearest
            power of 2, at least 16.</param>
            <param name="fill">The expansion threshold. Must be between 10% and 90%.</param>
            <param name="keyequalityComparer">The external key equalitySCG.Comparer</param>
        </member>
        <member name="T:C5.HashSet`1">
            <summary>
            A set collection class based on linear hashing
            </summary>
        </member>
        <member name="T:C5.HashSet`1.Feature">
            <summary>
            Enum class to assist printing of compilation alternatives.
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.Dummy">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.RefTypeBucket">
            <summary>
            Buckets are of reference type
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.ValueTypeBucket">
            <summary>
            Primary buckets are of value type
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.LinearProbing">
            <summary>
            Using linear probing to resolve index clashes
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.ShrinkTable">
            <summary>
            Shrink table when very sparsely filled
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.Chaining">
            <summary>
            Use chaining to resolve index clashes
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.InterHashing">
            <summary>
            Use hash function on item hash code
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.RandomInterHashing">
            <summary>
            Use a universal family of hash functions on item hash code
            </summary>
        </member>
        <member name="P:C5.HashSet`1.Features">
            <summary>
            Show which implementation features was chosen at compilation time
            </summary>
        </member>
        <member name="P:C5.HashSet`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashSet`1.searchoradd(`0@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Search for an item equal (according to itemequalityComparer) to the supplied item.  
            </summary>
            <param name="item"></param>
            <param name="add">If true, add item to table if not found.</param>
            <param name="update">If true, update table entry if item found.</param>
            <param name="raise">If true raise events</param>
            <returns>True if found</returns>
        </member>
        <member name="M:C5.HashSet`1.#ctor">
            <summary>
            Create a hash set with natural item equalityComparer and default fill threshold (66%)
            and initial table size (16).
            </summary>
        </member>
        <member name="M:C5.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash set with external item equalityComparer and default fill threshold (66%)
            and initial table size (16).
            </summary>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash set with external item equalityComparer and default fill threshold (66%)
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.HashSet`1.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a hash set with external item equalityComparer.
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="fill">Fill threshold (in range 10% to 90%)</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="P:C5.HashSet`1.ContainsSpeed">
            <summary>
            The complexity of the Contains operation
            </summary>
            <value>Always returns Speed.Constant</value>
        </member>
        <member name="M:C5.HashSet`1.Contains(`0)">
            <summary>
            Check if an item is in the set 
            </summary>
            <param name="item">The item to look for</param>
            <returns>True if set contains item</returns>
        </member>
        <member name="M:C5.HashSet`1.Find(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so report the actual item object found.
            </summary>
            <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
            <returns>True if set contains item</returns>
        </member>
        <member name="M:C5.HashSet`1.Update(`0)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:C5.HashSet`1.Update(`0,`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <param name="olditem"></param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:C5.HashSet`1.FindOrAdd(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set.
            If found, report the actual item object in the set,
            else add the supplied one.
            </summary>
            <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
            <returns>True if item was found</returns>
        </member>
        <member name="M:C5.HashSet`1.UpdateOrAdd(`0)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:C5.HashSet`1.UpdateOrAdd(`0,`0@)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <param name="olditem"></param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:C5.HashSet`1.Remove(`0)">
            <summary>
            Remove an item from the set
            </summary>
            <param name="item">The item to remove</param>
            <returns>True if item was (found and) removed </returns>
        </member>
        <member name="M:C5.HashSet`1.Remove(`0,`0@)">
            <summary>
            Remove an item from the set, reporting the actual matching item object.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if item was found.</returns>
        </member>
        <member name="M:C5.HashSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a supplied collection from this set.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashSet`1.Clear">
            <summary>
            Remove all items from the set, resetting internal table to initial size.
            </summary>
        </member>
        <member name="M:C5.HashSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items *not* in a supplied collection from this set.
            </summary>
            <param name="items">The items to retain</param>
        </member>
        <member name="M:C5.HashSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in a supplied collection is in this set
            (ignoring multiplicities). 
            </summary>
            <param name="items">The items to look for.</param>
            <returns>True if all items are found.</returns>
        </member>
        <member name="M:C5.HashSet`1.ToArray">
            <summary>
            Create an array containing all items in this set (in enumeration order).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.HashSet`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item is in this set (either 0 or 1).
            </summary>
            <param name="item">The item to look for.</param>
            <returns>1 if item is in set, 0 else</returns>
        </member>
        <member name="M:C5.HashSet`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashSet`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashSet`1.RemoveAllCopies(`0)">
            <summary>
            Remove all (at most 1) copies of item from this set.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:C5.HashSet`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.HashSet`1.GetEnumerator">
            <summary>
            Create an enumerator for this set.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.HashSet`1.AllowsDuplicates">
            <summary>
            Report if this is a set collection.
            </summary>
            <value>Always false</value>
        </member>
        <member name="P:C5.HashSet`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.HashSet`1.Add(`0)">
            <summary>
            Add an item to this set.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added (i.e. not found)</returns>
        </member>
        <member name="M:C5.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this set.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:C5.HashSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashSet`1.Check">
            <summary>
            Test internal structure of data (invariants)
            </summary>
            <returns>True if pass</returns>
        </member>
        <member name="M:C5.HashSet`1.BucketCostDistribution">
            <summary>
            Produce statistics on distribution of bucket sizes. Current implementation is incomplete.
            </summary>
            <returns>Histogram data.</returns>
        </member>
        <member name="T:C5.IntervalHeap`1">
            <summary>
            A priority queue class based on an interval heap data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="P:C5.IntervalHeap`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor">
            <summary>
            Create an interval heap with natural item comparer and default initial capacity (16)
            </summary>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create an interval heap with external item comparer and default initial capacity (16)
            </summary>
            <param name="comparer">The external comparer</param>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor(System.Int32)">
            <summary>
            Create an interval heap with natural item comparer and prescribed initial capacity
            </summary>
            <param name="capacity">The initial capacity</param>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create an interval heap with external item comparer and prescribed initial capacity
            </summary>
            <param name="comparer">The external comparer</param>
            <param name="capacity">The initial capacity</param>
        </member>
        <member name="M:C5.IntervalHeap`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            <exception cref="T:C5.NoSuchItemException"/> if queue is empty
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            <exception cref="T:C5.NoSuchItemException"/> if queue is empty
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            <exception cref="T:C5.NoSuchItemException"/> if queue is empty
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            <exception cref="T:C5.NoSuchItemException"/> if queue is empty
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="P:C5.IntervalHeap`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="P:C5.IntervalHeap`1.IsReadOnly">
            <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code>
            </summary>
            <value>True if this collection is read-only.</value>
        </member>
        <member name="P:C5.IntervalHeap`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True since this collection has bag semantics</value>
        </member>
        <member name="P:C5.IntervalHeap`1.EqualityComparer">
            <summary>
            Value is null since this collection has no equality concept for its items. 
            </summary>
            <value></value>
        </member>
        <member name="P:C5.IntervalHeap`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.IntervalHeap`1.Add(`0)">
            <summary>
            Add an item to this priority queue.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="P:C5.IntervalHeap`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:C5.IntervalHeap`1.Count">
            <summary>
            
            </summary>
            <value>The size of this collection</value>
        </member>
        <member name="P:C5.IntervalHeap`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:C5.IntervalHeap`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.IntervalHeap`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            <para>Note: the enumerator does *not* enumerate the items in sorted order, 
            but in the internal table order.</para>
            </summary>
            <returns>The enumerator(SIC)</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            Only available in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="F:C5.IntervalHeap`1.Handle.index">
            <summary>
            To save space, the index is 2*cell for heap[cell].first, and 2*cell+1 for heap[cell].last
            </summary>
        </member>
        <member name="P:C5.IntervalHeap`1.Item(C5.IPriorityQueueHandle{`0})">
            <summary>
            Get or set the item corresponding to a handle. 
            </summary>
            <exception cref="T:C5.InvalidPriorityQueueHandleException">if the handle is invalid for this queue</exception>
            <param name="handle">The reference into the heap</param>
            <returns></returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Find(C5.IPriorityQueueHandle{`0},`0@)">
            <summary>
            Check safely if a handle is valid for this queue and if so, report the corresponding queue item.
            </summary>
            <param name="handle">The handle to check</param>
            <param name="item">If the handle is valid this will contain the corresponding item on output.</param>
            <returns>True if the handle is valid.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Add(C5.IPriorityQueueHandle{`0}@,`0)">
            <summary>
            Add an item to the priority queue, receiving a 
            handle for the item in the queue, 
            or reusing an already existing handle.
            </summary>
            <param name="handle">On output: a handle for the added item. 
            On input: null for allocating a new handle, an invalid handle for reuse. 
            A handle for reuse must be compatible with this priority queue, 
            by being created by a priority queue of the same runtime type, but not 
            necessarily the same priority queue object.</param>
            <param name="item">The item to add.</param>
            <returns>True since item will always be added unless the call throws an exception.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Delete(C5.IPriorityQueueHandle{`0})">
            <summary>
            Delete an item with a handle from a priority queue.
            </summary>
            <exception cref="T:C5.InvalidPriorityQueueHandleException">if the handle is invalid</exception>
            <param name="handle">The handle for the item. The handle will be invalidated, but reusable.</param>
            <returns>The deleted item</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Replace(C5.IPriorityQueueHandle{`0},`0)">
            <summary>
            Replace an item with a handle in a priority queue with a new item. 
            Typically used for changing the priority of some queued object.
            </summary>
            <param name="handle">The handle for the old item</param>
            <param name="item">The new item</param>
            <returns>The old item</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.FindMin(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <param name="handle">On return: the handle of the item.</param>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.FindMax(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <param name="handle">On return: the handle of the item.</param>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.DeleteMin(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Remove the least item from this priority queue.
            </summary>
            <param name="handle">On return: the handle of the removed item.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.DeleteMax(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Remove the largest item from this priority queue.
            </summary>
            <param name="handle">On return: the handle of the removed item.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="T:C5.IDirectedEnumerable`1">
            <summary>
            A generic collection, that can be enumerated backwards.
            </summary>
        </member>
        <member name="M:C5.IDirectedEnumerable`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.IDirectedEnumerable`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.ICollectionValue`1">
            <summary>
            A generic collection that may be enumerated and can answer
            efficiently how many items it contains. Like <code>IEnumerable&lt;T&gt;</code>,
            this interface does not prescribe any operations to initialize or update the 
            collection. The main usage for this interface is to be the return type of 
            query operations on generic collection.
            </summary>
        </member>
        <member name="P:C5.ICollectionValue`1.ListenableEvents">
            <summary>
            A flag bitmap of the events subscribable to by this collection.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.ICollectionValue`1.ActiveEvents">
            <summary>
            A flag bitmap of the events currently subscribed to by this collection.
            </summary>
            <value></value>
        </member>
        <member name="E:C5.ICollectionValue`1.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:C5.ICollectionValue`1.CollectionCleared">
            <summary>
            The change event. Will be raised for every clear operation on the collection.
            </summary>
        </member>
        <member name="E:C5.ICollectionValue`1.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="E:C5.ICollectionValue`1.ItemInserted">
            <summary>
            The item inserted  event. Will be raised for every individual insertion to the collection.
            </summary>
        </member>
        <member name="E:C5.ICollectionValue`1.ItemsRemoved">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="E:C5.ICollectionValue`1.ItemRemovedAt">
            <summary>
            The item removed at event. Will be raised for every individual removal at from the collection.
            </summary>
        </member>
        <member name="P:C5.ICollectionValue`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:C5.ICollectionValue`1.Count">
            <summary>
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="P:C5.ICollectionValue`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:C5.ICollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The index at which to copy the first item</param>
        </member>
        <member name="M:C5.ICollectionValue`1.ToArray">
            <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.ICollectionValue`1.Apply(System.Action{`0})">
            <summary>
            Apply a delegate to all items of this collection.
            </summary>
            <param name="action">The delegate to apply</param>
        </member>
        <member name="M:C5.ICollectionValue`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
            <param name="predicate">A  delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.ICollectionValue`1.Find(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.ICollectionValue`1.All(System.Func{`0,System.Boolean})">
            <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="M:C5.ICollectionValue`1.Choose">
            <summary>
            Choose some item of this collection. 
            <para>Implementations must assure that the item 
            returned may be efficiently removed.</para>
            <para>Implementors may decide to implement this method in a way such that repeated
            calls do not necessarily give the same result, i.e. so that the result of the following 
            test is undetermined:
            <code>coll.Choose() == coll.Choose()</code></para>
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.ICollectionValue`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="filter">The T->bool filter delegate defining the condition</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="T:C5.IDirectedCollectionValue`1">
            <summary>
            A sized generic collection, that can be enumerated backwards.
            </summary>
        </member>
        <member name="M:C5.IDirectedCollectionValue`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:C5.IDirectedCollectionValue`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="T:C5.IExtensible`1">
            <summary>
            A generic collection to which one may add items. This is just the intersection
            of the main stream generic collection interfaces and the priority queue interface,
            <see cref="T:C5.ICollection`1"/> and <see cref="T:C5.IPriorityQueue`1"/>.
            </summary>
        </member>
        <member name="P:C5.IExtensible`1.IsReadOnly">
            <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code>
            </summary>
            <value>True if this collection is read-only.</value>
        </member>
        <member name="P:C5.IExtensible`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False if this collection has set semantics, true if bag semantics.</value>
        </member>
        <member name="P:C5.IExtensible`1.EqualityComparer">
            <summary>
            (Here should be a discussion of the role of equalityComparers. Any ). 
            </summary>
            <value>The equalityComparer used by this collection to check equality of items. 
            Or null (????) if collection does not check equality at all or uses a comparer.</value>
        </member>
        <member name="P:C5.IExtensible`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.IExtensible`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.IExtensible`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            <i>This is only relevant for developers of the library</i>
            </summary>
            <returns>True if check was passed.</returns>
        </member>
        <member name="T:C5.ICollection`1">
            <summary>
            The simplest interface of a main stream generic collection
            with lookup, insertion and removal operations. 
            </summary>
        </member>
        <member name="P:C5.ICollection`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant). 
            <para>See <see cref="T:C5.Speed"/> for the set of symbols.</para>
            </summary>
            <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this collection.</value>
        </member>
        <member name="P:C5.ICollection`1.Count">
            <summary>
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="P:C5.ICollection`1.IsReadOnly">
            <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code>
            </summary>
            <value>True if this collection is read-only.</value>
        </member>
        <member name="M:C5.ICollection`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.ICollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The index at which to copy the first item</param>
        </member>
        <member name="M:C5.ICollection`1.GetUnsequencedHashCode">
            <summary>
            The unordered collection hashcode is defined as the sum of 
            <code>h(hashcode(item))</code> over the items
            of the collection, where the function <code>h</code> is a function from 
            int to int of the form <code> t -> (a0*t+b0)^(a1*t+b1)^(a2*t+b2)</code>, where 
            the ax and bx are the same for all collection classes. 
            <para>The current implementation uses fixed values for the ax and bx, 
            specified as constants in the code.</para>
            </summary>
            <returns>The unordered hashcode of this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            Compare the contents of this collection to another one without regards to
            the sequence order. The comparison will use this collection's itemequalityComparer
            to compare individual items.
            </summary>
            <param name="otherCollection">The collection to compare to.</param>
            <returns>True if this collection and that contains the same items.</returns>
        </member>
        <member name="M:C5.ICollection`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.ICollection`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.ICollection`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.ICollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check whether this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.ICollection`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a (binary copy of) the supplied value. If the collection has bag semantics,
            it depends on the value of DuplicatesByCounting if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ICollection`1.Update(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a (binary copy of) the supplied value. If the collection has bag semantics,
            it depends on the value of DuplicatesByCounting if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <param name="olditem">On output the olditem, if found.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ICollection`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.ICollection`1.UpdateOrAdd(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <param name="olditem">On output the olditem, if found.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.ICollection`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ICollection`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The value removed if any.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ICollection`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.ICollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.ICollection`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.ICollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="T:C5.ISequenced`1">
             <summary>
             An editable collection maintaining a definite sequence order of the items.
            
             <i>Implementations of this interface must compute the hash code and 
             equality exactly as prescribed in the method definitions in order to
             be consistent with other collection classes implementing this interface.</i>
             <i>This interface is usually implemented by explicit interface implementation,
             not as ordinary virtual methods.</i>
             </summary>
        </member>
        <member name="M:C5.ISequenced`1.GetSequencedHashCode">
            <summary>
            The hashcode is defined as <code>h(...h(h(h(x1),x2),x3),...,xn)</code> for
            <code>h(a,b)=CONSTANT*a+b</code> and the x's the hash codes of the items of 
            this collection.
            </summary>
            <returns>The sequence order hashcode of this collection.</returns>
        </member>
        <member name="M:C5.ISequenced`1.SequencedEquals(C5.ISequenced{`0})">
            <summary>
            Compare this sequenced collection to another one in sequence order.
            </summary>
            <param name="otherCollection">The sequenced collection to compare to.</param>
            <returns>True if this collection and that contains equal (according to
            this collection's itemequalityComparer) in the same sequence order.</returns>
        </member>
        <member name="T:C5.IIndexed`1">
            <summary>
            A sequenced collection, where indices of items in the order are maintained
            </summary>
        </member>
        <member name="P:C5.IIndexed`1.Count">
            <summary>
            Gets the number of elements in the collection.
            </summary>
        </member>
        <member name="P:C5.IIndexed`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.IIndexed`1.Item(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="M:C5.IIndexed`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start. 
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start. A negative number if item not found, 
            namely the one's complement of the index at which the Add operation would put the item.</returns>
        </member>
        <member name="M:C5.IIndexed`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end. A negative number if item not found, 
            namely the two-complement of the index at which the Add operation would put the item.</returns>
        </member>
        <member name="M:C5.IIndexed`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:C5.IIndexed`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:C5.IIndexed`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
            <param name="index">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IIndexed`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if start or count 
            is negative or start+count &gt; the size of the collection.</exception>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="T:C5.IStack`1">
            <summary>
            The interface describing the operations of a LIFO stack data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="P:C5.IStack`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.IStack`1.Item(System.Int32)">
            <summary>
            Get the <code>index</code>'th element of the stack.  The bottom of the stack has index 0.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IStack`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.IStack`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="T:C5.IQueue`1">
            <summary>
            The interface describing the operations of a FIFO queue data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="P:C5.IQueue`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.IQueue`1.Item(System.Int32)">
            <summary>
            Get the <code>index</code>'th element of the queue.  The front of the queue has index 0.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IQueue`1.Enqueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.IQueue`1.Dequeue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="T:C5.IList`1">
             <summary>
             This is an indexed collection, where the item order is chosen by 
             the user at insertion time.
            
             NBNBNB: we need a description of the view functionality here!
             </summary>
        </member>
        <member name="P:C5.IList`1.First">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.IList`1.Last">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.IList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end.</value>
        </member>
        <member name="P:C5.IList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
            <value>The index'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.IList`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.IList`1.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.IList`1.Add(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IList`1.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.IList`1.Contains(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IList`1.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:C5.IList`1.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IList`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start. 
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start. A negative number if item not found, 
            namely the one's complement of the index at which the Add operation would put the item.</returns>
        </member>
        <member name="M:C5.IList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
            <param name="index">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.Insert(C5.IList{`0},`0)">
            <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoint of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para>
            </summary>
            <exception cref="T:C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
            <exception cref="T:System.IndexOutOfRangeException"><b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.IList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            <exception cref="T:C5.DuplicateNotAllowedException"/> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            <exception cref="T:C5.DuplicateNotAllowedException"/> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt; the size of the collection.</exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> if the list has 
            <code>AllowsDuplicates==false</code> and one of the items to insert is
            already in the list.</exception>
            <param name="index">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.IList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.IList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default equalityComparer for the item type V.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.IList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="equalityComparer">The equalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.IList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the view would not fit into
            this list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.IList`1.ViewOf(`0)">
            <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            <exception cref="T:C5.NoSuchItemException"/> if the item is not in this list.
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.IList`1.LastViewOf(`0)">
            <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:C5.NoSuchItemException"/> if the item is not in this list.
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="P:C5.IList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.IList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for an underlying list.</value>
        </member>
        <member name="P:C5.IList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.IList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.IList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.IList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IList`1.Span(C5.IList{`0})">
            <summary>
            
            <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
            </summary>
            <param name="otherView"></param>
            <exception cref="T:C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If <code>otherView</code> is strictly to the left of this view</exception>
            <returns></returns>
        </member>
        <member name="M:C5.IList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.IList`1.IsSorted">
            <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.IList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="comparer">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.IList`1.Sort">
            <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
        </member>
        <member name="M:C5.IList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specified sorting order.
            <para>The sorting does not perform duplicate elimination or identify items
            according to the comparer or itemequalityComparer. I.e. the list as an 
            unsequenced collection with binary equality, will not change.
            </para>
            </summary>
            <param name="comparer">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.IList`1.Shuffle">
            <summary>
            Randomly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:C5.IList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="T:C5.IPriorityQueueHandle`1">
            <summary>
            The base type of a priority queue handle
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:C5.IPriorityQueue`1">
            <summary>
            A generic collection of items prioritized by a comparison (order) relation.
            Supports adding items and reporting or removing extremal elements. 
            <para>
            
            </para>
            When adding an item, the user may choose to have a handle allocated for this item in the queue. 
            The resulting handle may be used for deleting the item even if not extremal, and for replacing the item.
            A priority queue typically only holds numeric priorities associated with some objects
            maintained separately in other collection objects.
            </summary>
        </member>
        <member name="M:C5.IPriorityQueue`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.DeleteMax">
            <summary>
            Remove the largest item from this priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="P:C5.IPriorityQueue`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="P:C5.IPriorityQueue`1.Item(C5.IPriorityQueueHandle{`0})">
            <summary>
            Get or set the item corresponding to a handle. Throws exceptions on 
            invalid handles.
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.Find(C5.IPriorityQueueHandle{`0},`0@)">
            <summary>
            Check if the entry corresponding to a handle is in the priority queue.
            </summary>
            <param name="handle"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.Add(C5.IPriorityQueueHandle{`0}@,`0)">
            <summary>
            Add an item to the priority queue, receiving a 
            handle for the item in the queue, 
            or reusing an existing unused handle.
            </summary>
            <param name="handle">On output: a handle for the added item. 
            On input: null for allocating a new handle, or a currently unused handle for reuse. 
            A handle for reuse must be compatible with this priority queue, 
            by being created by a priority queue of the same runtime type, but not 
            necessarily the same priority queue object.</param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.Delete(C5.IPriorityQueueHandle{`0})">
            <summary>
            Delete an item with a handle from a priority queue
            </summary>
            <param name="handle">The handle for the item. The handle will be invalidated, but reusable.</param>
            <returns>The deleted item</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.Replace(C5.IPriorityQueueHandle{`0},`0)">
            <summary>
            Replace an item with a handle in a priority queue with a new item. 
            Typically used for changing the priority of some queued object.
            </summary>
            <param name="handle">The handle for the old item</param>
            <param name="item">The new item</param>
            <returns>The old item</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.FindMin(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <param name="handle">On return: the handle of the item.</param>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.FindMax(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <param name="handle">On return: the handle of the item.</param>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.DeleteMin(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <param name="handle">On return: the handle of the removed item.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.DeleteMax(C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <param name="handle">On return: the handle of the removed item.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="T:C5.ISorted`1">
            <summary>
            A sorted collection, i.e. a collection where items are maintained and can be searched for in sorted order.
            Thus the sequence order is given as a sorting order.
            
            <para>The sorting order is defined by a comparer, an object of type IComparer&lt;T&gt; 
            (<see cref="T:C5.IComparer`1"/>). Implementors of this interface will normally let the user 
            define the comparer as an argument to a constructor. 
            Usually there will also be constructors without a comparer argument, in which case the 
            comparer should be the defalt comparer for the item type, <see cref="P:C5.Comparer`1.Default"/>.</para>
            
            <para>The comparer of the sorted collection is available as the <code>System.Collections.Generic.Comparer</code> property 
            (<see cref="P:C5.ISorted`1.Comparer"/>).</para>
            
            <para>The methods are grouped according to
            <list>
            <item>Extrema: report or report and delete an extremal item. This is reminiscent of simplified priority queues.</item>
            <item>Nearest neighbor: report predecessor or successor in the collection of an item. Cut belongs to this group.</item>
            <item>Range: report a view of a range of elements or remove all elements in a range.</item>
            <item>AddSorted: add a collection of items known to be sorted in the same order (should be faster) (to be removed?)</item>
            </list>
            </para>
            
            <para>Since this interface extends ISequenced&lt;T&gt;, sorted collections will also have an 
            item equalityComparer (<see cref="P:C5.IExtensible`1.EqualityComparer"/>). This equalityComparer will not be used in connection with 
            the inner workings of the sorted collection, but will be used if the sorted collection is used as 
            an item in a collection of unsequenced or sequenced collections, 
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)</para>
            
            <para>Note that code may check if two sorted collections has the same sorting order 
            by checking if the Comparer properties are equal. This is done a few places in this library
            for optimization purposes.</para>
            </summary>
        </member>
        <member name="M:C5.ISorted`1.FindMin">
            <summary>
            Find the current least item of this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.ISorted`1.DeleteMin">
            <summary>
            Remove the least item from this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ISorted`1.FindMax">
            <summary>
            Find the current largest item of this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.ISorted`1.DeleteMax">
            <summary>
            Remove the largest item from this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="P:C5.ISorted`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this sorted collection.
            </summary>
            <value>The comparer</value>
        </member>
        <member name="M:C5.ISorted`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.ISorted`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:C5.ISorted`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.ISorted`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:C5.ISorted`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            that is, the largest item in the collection less than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.ISorted`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.ISorted`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            that is, the largest item in the collection less than or equal to the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.ISorted`1.WeakSuccessor(`0)">
             <summary>
             Find the weak successor in the sorted collection of a particular value,
             that is, the least item in the collection greater than or equal to the supplied value.
             </summary>
             <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
             supplied  value is greater than the maximum of this collection.)</exception>
            <param name="item">The item to find the weak successor for.</param>
             <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.ISorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Given a "cut" function from the items of the sorted collection to <code>int</code>
            whose only sign changes when going through items in increasing order
            can be 
            <list>
            <item>from positive to zero</item>
            <item>from positive to negative</item>
            <item>from zero to negative</item>
            </list>
            The "cut" function is supplied as the <code>CompareTo</code> method 
            of an object <code>c</code> implementing 
            <code>IComparable&lt;T&gt;</code>. 
            A typical example is the case where <code>T</code> is comparable and 
            <code>cutFunction</code> is itself of type <code>T</code>.
            <para>This method performs a search in the sorted collection for the ranges in which the
            "cut" function is negative, zero respectively positive. If <code>T</code> is comparable
            and <code>c</code> is of type <code>T</code>, this is a safe way (no exceptions thrown) 
            to find predecessor and successor of <code>c</code>.
            </para>
            <para> If the supplied cut function does not satisfy the sign-change condition, 
            the result of this call is undefined.
            </para>
            
            </summary>
            <param name="cutFunction">The cut function <code>T</code> to <code>int</code>, given
            by the <code>CompareTo</code> method of an object implementing 
            <code>IComparable&lt;T&gt;</code>.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">Returns true if the cut function is positive somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">Returns true if the cut function is negative somewhere
            on this collection.</param>
            <returns>True if the cut function is zero somewhere
            on this collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            </summary>
            <exception cref="T:System.ArgumentException"> if the enumerated items turns out
            not to be in increasing order.</exception>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.ISorted`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.ISorted`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.ISorted`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="T:C5.IIndexedSorted`1">
            <summary>
            A collection where items are maintained in sorted order together
            with their indexes in that order.
            </summary>
        </member>
        <member name="M:C5.IIndexedSorted`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="predicate">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="comparer">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="T:C5.IPersistentSorted`1">
            <summary>
            The type of a sorted collection with persistence
            </summary>
        </member>
        <member name="M:C5.IPersistentSorted`1.Snapshot">
            <summary>
            Make a (read-only) snap shot of this collection.
            </summary>
            <returns>The snap shot.</returns>
        </member>
        <member name="T:C5.IDictionary`2">
            <summary>
            A dictionary with keys of type K and values of type V. Equivalent to a
            finite partial map from K to V.
            </summary>
        </member>
        <member name="P:C5.IDictionary`2.EqualityComparer">
            <summary>
            The key equalityComparer.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.IDictionary`2.Item(`0)">
            <summary>
            Indexer for dictionary.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no entry is found. </exception>
            <value>The value corresponding to the key</value>
        </member>
        <member name="P:C5.IDictionary`2.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if dictionary is read-only</value>
        </member>
        <member name="P:C5.IDictionary`2.Keys">
            <summary>
            
            </summary>
            <value>A collection containing all the keys of the dictionary</value>
        </member>
        <member name="P:C5.IDictionary`2.Values">
            <summary>
            
            </summary>
            <value>A collection containing all the values of the dictionary</value>
        </member>
        <member name="P:C5.IDictionary`2.Func">
            <summary>
            
            </summary>
            <value>A delegate of type <see cref="T:Func`2"/> defining the partial function from K to V give by the dictionary.</value>
        </member>
        <member name="M:C5.IDictionary`2.Add(`0,`1)">
            <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException"> if there already is an entry with the same key. </exception>>
            <param name="key">Key to add</param>
            <param name="val">Value to add</param>
        </member>
        <member name="M:C5.IDictionary`2.AddAll``2(System.Collections.Generic.IEnumerable{C5.KeyValuePair{``0,``1}})">
            <summary>
            Add the entries from a collection of <see cref="T:C5.KeyValuePair`2"/> pairs to this dictionary.
            </summary>
            <exception cref="T:C5.DuplicateNotAllowedException"> 
            If the input contains duplicate keys or a key already present in this dictionary.</exception>
            <param name="entries"></param>
        </member>
        <member name="P:C5.IDictionary`2.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant). 
            <para>See <see cref="T:C5.Speed"/> for the set of symbols.</para>
            </summary>
            <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this dictionary.</value>
        </member>
        <member name="M:C5.IDictionary`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check whether this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.IDictionary`2.Remove(`0)">
            <summary>
            Remove an entry with a given key from the dictionary
            </summary>
            <param name="key">The key of the entry to remove</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.IDictionary`2.Remove(`0,`1@)">
            <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
            <param name="key">The key of the entry to remove</param>
            <param name="val">On exit, the value of the removed entry</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.IDictionary`2.Clear">
            <summary>
            Remove all entries from the dictionary
            </summary>
        </member>
        <member name="M:C5.IDictionary`2.Contains(`0)">
            <summary>
            Check if there is an entry with a specified key
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.Find(`0@,`1@)">
            <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On exit, the value of the entry</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.Update(`0,`1)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The new value</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.Update(`0,`1,`1@)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val" reporting the old value.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The new value</param>
            <param name="oldval">The old value if any</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.FindOrAdd(`0,`1@)">
            <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.UpdateOrAdd(`0,`1)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The value to add or replace with.</param>
            <returns>True if key was found and value updated.</returns>
        </member>
        <member name="M:C5.IDictionary`2.UpdateOrAdd(`0,`1,`1@)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The value to add or replace with.</param>
            <param name="oldval">The old value if any</param>
            <returns>True if key was found and value updated.</returns>
        </member>
        <member name="M:C5.IDictionary`2.Check">
            <summary>
            Check the integrity of the internal data structures of this dictionary.
            Only available in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="T:C5.ISortedDictionary`2">
            <summary>
            A dictionary with sorted keys.
            </summary>
        </member>
        <member name="P:C5.ISortedDictionary`2.Keys">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.ISortedDictionary`2.FindMin">
            <summary>
            Find the current least item of this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.DeleteMin">
            <summary>
            Remove the least item from this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.FindMax">
            <summary>
            Find the current largest item of this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.DeleteMax">
            <summary>
            Remove the largest item from this sorted collection.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="P:C5.ISortedDictionary`2.Comparer">
            <summary>
            The key comparer used by this dictionary.
            </summary>
            <value></value>
        </member>
        <member name="M:C5.ISortedDictionary`2.TryPredecessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a predecessor</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.TrySuccessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The successor, if any</param>
            <returns>True if the key has a successor</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.TryWeakPredecessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a weak predecessor</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.TryWeakSuccessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The weak successor, if any</param>
            <returns>True if the key has a weak successor</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.Predecessor(`0)">
            <summary>
            Find the entry with the largest key less than a given key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.Successor(`0)">
            <summary>
            Find the entry with the least key greater than a given key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.WeakPredecessor(`0)">
            <summary>
            Find the entry with the largest key less than or equal to a given key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.WeakSuccessor(`0)">
            <summary>
            Find the entry with the least key greater than or equal to a given key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.Cut(System.IComparable{`0},C5.KeyValuePair{`0,`1}@,System.Boolean@,C5.KeyValuePair{`0,`1}@,System.Boolean@)">
            <summary>
            Given a "cut" function from the items of the sorted collection to <code>int</code>
            whose only sign changes when going through items in increasing order
            can be 
            <list>
            <item>from positive to zero</item>
            <item>from positive to negative</item>
            <item>from zero to negative</item>
            </list>
            The "cut" function is supplied as the <code>CompareTo</code> method 
            of an object <code>c</code> implementing 
            <code>IComparable&lt;K&gt;</code>. 
            A typical example is the case where <code>K</code> is comparable and 
            <code>c</code> is itself of type <code>K</code>.
            <para>This method performs a search in the sorted collection for the ranges in which the
            "cut" function is negative, zero respectively positive. If <code>K</code> is comparable
            and <code>c</code> is of type <code>K</code>, this is a safe way (no exceptions thrown) 
            to find predecessor and successor of <code>c</code>.
            </para>
            <para> If the supplied cut function does not satisfy the sign-change condition, 
            the result of this call is undefined.
            </para>
            
            </summary>
            <param name="cutFunction">The cut function <code>K</code> to <code>int</code>, given
            by the <code>CompareTo</code> method of an object implementing 
            <code>IComparable&lt;K&gt;</code>.</param>
            <param name="lowEntry">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">Returns true if the cut function is positive somewhere
            on this collection.</param>
            <param name="highEntry">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">Returns true if the cut function is negative somewhere
            on this collection.</param>
            <returns>True if the cut function is zero somewhere
            on this collection.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="lowerBound">The lower bound (inclusive).</param>
            <param name="upperBound">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.AddSorted(System.Collections.Generic.IEnumerable{C5.KeyValuePair{`0,`1}})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            </summary>
            <exception cref="T:System.ArgumentException"> if the enumerated items turns out
            not to be in increasing order.</exception>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.ISortedDictionary`2.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.ISortedDictionary`2.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.ISortedDictionary`2.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="T:C5.HashedLinkedList`1">
            <summary>
            A list collection class based on a doubly linked list data structure.
            </summary>
        </member>
        <member name="F:C5.HashedLinkedList`1.fIFO">
            <summary>
            IExtensible.Add(T) always does AddLast(T), fIFO determines 
            if T Remove() does RemoveFirst() or RemoveLast()
            </summary>
        </member>
        <member name="P:C5.HashedLinkedList`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="F:C5.HashedLinkedList`1.startsentinel">
            <summary>
            Node to the left of first node 
            </summary>
        </member>
        <member name="F:C5.HashedLinkedList`1.endsentinel">
            <summary>
            Node to the right of last node
            </summary>
        </member>
        <member name="F:C5.HashedLinkedList`1.offset">
            <summary>
            Offset of this view in underlying list
            </summary>
        </member>
        <member name="F:C5.HashedLinkedList`1.underlying">
            <summary>
            underlying list of this view (or null for the underlying list)
            </summary>
        </member>
        <member name="F:C5.HashedLinkedList`1.isValid">
            <summary>
            Has this list or view not been invalidated by some operation (by someone calling Dispose())
            </summary>
        </member>
        <member name="F:C5.HashedLinkedList`1.taggroups">
            <summary>
            Number of taggroups
            </summary>
        </member>
        <member name="P:C5.HashedLinkedList`1.Taggroups">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashedLinkedList`1.updatecheck">
            <summary>
            Check if it is valid to perform updates and increment stamp of 
            underlying if this is a view.
            <para>This method should be called in every public modifying 
            methods before any modifications are performed.
            </para>
            </summary>
            <exception cref="T:System.InvalidOperationException"> if check fails.</exception>
        </member>
        <member name="M:C5.HashedLinkedList`1.validitycheck">
            <summary>
            Check if we are a view that the underlying list has only been updated through us.
            <br/>
            This method should be called from enumerators etc to guard against 
            modification of the base collection.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if check fails.</exception>
        </member>
        <member name="M:C5.HashedLinkedList`1.modifycheck(System.Int32)">
            <summary>
            Check that the list has not been updated since a particular time.
            </summary>
            <param name="stamp">The stamp indicating the time.</param>
            <exception cref="T:C5.CollectionModifiedException"> if check fails.</exception>
        </member>
        <member name="M:C5.HashedLinkedList`1.find(`0,C5.HashedLinkedList{`0}.Node@,System.Int32@)">
            <summary>
            Search forwards from a node for a node with a particular item.
            </summary>
            <param name="item">The item to look for</param>
            <param name="node">On input, the node to start at. If item was found, the node found on output.</param>
            <param name="index">If node was found, the value will be the number of links followed higher than 
            the value on input. If item was not found, the value on output is undefined.</param>
            <returns>True if node was found.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.get(System.Int32)">
            <summary>
            Return the node at position pos
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.dist(System.Int32,System.Int32@,System.Int32[])">
            <summary>
            Find the distance from pos to the set given by positions. Return the
            signed distance as return value and as an out parameter, the
            array index of the nearest position. This is used for up to length 5 of
            positions, and we do not assume it is sorted. 
            </summary>
            <param name="pos"></param>
            <param name="positions"></param>
            <param name="nearest"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.get(System.Int32,System.Int32[],C5.HashedLinkedList{`0}.Node[])">
            <summary>
            Find the node at position pos, given known positions of several nodes.
            </summary>
            <param name="pos"></param>
            <param name="positions"></param>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.getPair(System.Int32,System.Int32,C5.HashedLinkedList{`0}.Node@,C5.HashedLinkedList{`0}.Node@,System.Int32[],C5.HashedLinkedList{`0}.Node[])">
            <summary>
            Get nodes at positions p1 and p2, given nodes at several positions.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="n1"></param>
            <param name="n2"></param>
            <param name="positions"></param>
            <param name="nodes"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.insertNode(System.Boolean,C5.HashedLinkedList{`0}.Node,C5.HashedLinkedList{`0}.Node)">
            <summary>
            Insert a Node before another one. Unchecked version. 
            </summary>
            <param name="succ">The successor to be</param>
            <param name="newnode">Node to insert</param>
            <param name="updateViews">update overlapping view in this call</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.fixViewsAfterInsert(C5.HashedLinkedList{`0}.Node,C5.HashedLinkedList{`0}.Node,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="added">The actual number of inserted nodes</param>
            <param name="pred">The predecessor of the inserted nodes</param>
            <param name="succ">The successor of the added nodes</param>
            <param name="realInsertionIndex"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.viewPosition(C5.HashedLinkedList{`0})">
            <summary>
            
            </summary>
            <param name="otherView"></param>
            <returns>The position of View(otherOffset, otherSize) wrt. this view</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a linked list with en external item equalityComparer
            </summary>
            <param name="itemequalityComparer">The external equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.#ctor">
            <summary>
            Create a linked list with the natural item equalityComparer
            </summary>
        </member>
        <member name="T:C5.HashedLinkedList`1.Node">
            <summary>
            An individual cell in the linked list
            </summary>
        </member>
        <member name="T:C5.HashedLinkedList`1.TagGroup">
            <summary>
            A group of nodes with the same high tag. Purpose is to be
            able to tell the sequence order of two nodes without having to scan through
            the list.
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.TagGroup.ToString">
            <summary>
            Pretty print a tag group
            </summary>
            <returns>Formatted tag group</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.settag(C5.HashedLinkedList{`0}.Node)">
            <summary>
            Put a tag on a node (already inserted in the list). Split taggroups and renumber as 
            necessary.
            </summary>
            <param name="node">The node to tag</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.removefromtaggroup(C5.HashedLinkedList{`0}.Node)">
            <summary>
            Remove a node from its taggroup.
            <br/> When this is called, node must already have been removed from the underlying list
            </summary>
            <param name="node">The node to remove</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.splittaggroup(C5.HashedLinkedList{`0}.TagGroup)">
            <summary>
            Split a tag group to make rom for more tags.
            </summary>
            <param name="taggroup">The tag group</param>
        </member>
        <member name="T:C5.HashedLinkedList`1.Position">
            <summary>
            During RemoveAll, we need to cache the original endpoint indices of views
            </summary>
        </member>
        <member name="T:C5.HashedLinkedList`1.ViewHandler">
            <summary>
            Handle the update of (other) views during a multi-remove operation.
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.ViewHandler.updateViewSizesAndCounts(System.Int32,C5.HashedLinkedList{`0}.Node)">
            <summary>
            To be called with n pointing to the right of each node to be removed in a stretch. 
            And at the endsentinel. 
            
            Update offset of a view whose left endpoint (has not already been handled and) is n or precedes n.
            I.e. startsentinel precedes n.
            Also update the size as a prelude to handling the right endpoint.
            
            Update size of a view not already handled and whose right endpoint precedes n.
            </summary>
            <param name="removed">The number of nodes left of n to be removed</param>
            <param name="n"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.ViewHandler.updateSentinels(C5.HashedLinkedList{`0}.Node,C5.HashedLinkedList{`0}.Node,C5.HashedLinkedList{`0}.Node)">
            <summary>
            To be called with n being the first not-to-be-removed node after a (stretch of) node(s) to be removed.
            
            It will update the startsentinel of views (that have not been handled before and) 
            whose startsentinel precedes n, i.e. is to be deleted.
            
            It will update the endsentinel of views (...) whose endsentinel precedes n, i.e. is to be deleted.
            
            PROBLEM: DOESNT WORK AS ORIGINALLY ADVERTISED. WE MUST DO THIS BEFORE WE ACTUALLY REMOVE THE NODES. WHEN THE 
            NODES HAVE BEEN REMOVED, THE precedes METHOD WILL NOT WORK!
            </summary>
            <param name="n"></param>
            <param name="newstart"></param>
            <param name="newend"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Dispose">
            <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
        </member>
        <member name="P:C5.HashedLinkedList`1.First">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.HashedLinkedList`1.Last">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.HashedLinkedList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. THe default for a new linked list is true.</value>
        </member>
        <member name="P:C5.HashedLinkedList`1.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.HashedLinkedList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.HashedLinkedList`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.HashedLinkedList`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.</summary>
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Insert(C5.IList{`0},`0)">
            <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoint of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para>
            </summary>
            <exception cref="T:C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
            <exception cref="T:System.IndexOutOfRangeException"><b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list.
            </summary>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="equalityComparer">The equalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative</exception>
            <exception cref="T:System.ArgumentException"> if the range does not fit within list.</exception>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.ViewOf(`0)">
            <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            </summary>
            <exception cref="T:System.ArgumentException"> if the item is not in this list.</exception>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.LastViewOf(`0)">
            <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:System.ArgumentException"/> if the item is not in this list.
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="P:C5.HashedLinkedList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.HashedLinkedList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.HashedLinkedList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for a underlying list.</value>
        </member>
        <member name="M:C5.HashedLinkedList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, perhaps changing its size.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Span(C5.IList{`0})">
            <summary>
            
            <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
            </summary>
            <param name="otherView"></param>
            <exception cref="T:C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.IsSorted">
            <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Sort">
            <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class. 
            (<see cref="T:C5.Comparer`1"/>).
            The sorting is stable.
            </summary>
            <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
        </member>
        <member name="M:C5.HashedLinkedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            The sorting is stable.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Shuffle">
            <summary>
            Randomly shuffle the items of this list. 
            <para>Will invalidate overlapping views???</para>
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            <para>Will invalidate overlapping views???</para>
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="P:C5.HashedLinkedList`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.GetSequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.SequencedEquals(C5.ISequenced{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.HashedLinkedList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Linear</value>
        </member>
        <member name="M:C5.HashedLinkedList`1.GetUnsequencedHashCode">
            <summary>
            Performs a check for view validity before calling base.GetUnsequencedHashCode()
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. Will update a single item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. Since the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found (only one copy). 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <param name="removeditem">The value removed.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            <para>Always removes from the front of the list.
            </para>
            <para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this list, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>.
            </para>
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            <para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this collection, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>. The stated complexity 
            holds under the assumption that the itemequalityComparer of this list is well-behaved.
            </para>
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.RetainAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.HashedLinkedList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection
            with respect to multiplicities.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            <para>The asymptotic complexity of this method is <code>O(n+v*log(v))</code>, 
            where <code>n</code> is the size of the collection and <code>v</code> 
            is the number of views.
            </para>
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="P:C5.HashedLinkedList`1.Count">
            <summary>
            
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="M:C5.HashedLinkedList`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="filter">The T->bool filter delegate defining the condition</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. 
            </summary>
            <param name="item">The item to add.</param>
            <returns>True.</returns>
        </member>
        <member name="P:C5.HashedLinkedList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True since this collection has bag semantics.</value>
        </member>
        <member name="P:C5.HashedLinkedList`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.HashedLinkedList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Check">
            <summary>
            Check the sanity of this list
            </summary>
            <returns>true if sane</returns>
        </member>
        <member name="T:C5.LinkedList`1">
            <summary>
            A list collection class based on a doubly linked list data structure.
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.fIFO">
            <summary>
            IExtensible.Add(T) always does AddLast(T), fIFO determines 
            if T Remove() does RemoveFirst() or RemoveLast()
            </summary>
        </member>
        <member name="P:C5.LinkedList`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="F:C5.LinkedList`1.startsentinel">
            <summary>
            Node to the left of first node 
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.endsentinel">
            <summary>
            Node to the right of last node
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.offset">
            <summary>
            Offset of this view in underlying list
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.underlying">
            <summary>
            underlying list of this view (or null for the underlying list)
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.isValid">
            <summary>
            Has this list or view not been invalidated by some operation (by someone calling Dispose())
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.updatecheck">
            <summary>
            Check if it is valid to perform updates and increment stamp of 
            underlying if this is a view.
            <para>This method should be called in every public modifying 
            methods before any modifications are performed.
            </para>
            </summary>
            <exception cref="T:System.InvalidOperationException"> if check fails.</exception>
        </member>
        <member name="M:C5.LinkedList`1.validitycheck">
            <summary>
            Check if we are a view that the underlying list has only been updated through us.
            <br/>
            This method should be called from enumerators etc to guard against 
            modification of the base collection.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if check fails.</exception>
        </member>
        <member name="M:C5.LinkedList`1.modifycheck(System.Int32)">
            <summary>
            Check that the list has not been updated since a particular time.
            </summary>
            <param name="stamp">The stamp indicating the time.</param>
            <exception cref="T:C5.CollectionModifiedException"> if check fails.</exception>
        </member>
        <member name="M:C5.LinkedList`1.find(`0,C5.LinkedList{`0}.Node@,System.Int32@)">
            <summary>
            Search forwards from a node for a node with a particular item.
            </summary>
            <param name="item">The item to look for</param>
            <param name="node">On input, the node to start at. If item was found, the node found on output.</param>
            <param name="index">If node was found, the value will be the number of links followed higher than 
            the value on input. If item was not found, the value on output is undefined.</param>
            <returns>True if node was found.</returns>
        </member>
        <member name="M:C5.LinkedList`1.get(System.Int32)">
            <summary>
            Return the node at position pos
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.dist(System.Int32,System.Int32@,System.Int32[])">
            <summary>
            Find the distance from pos to the set given by positions. Return the
            signed distance as return value and as an out parameter, the
            array index of the nearest position. This is used for up to length 5 of
            positions, and we do not assume it is sorted. 
            </summary>
            <param name="pos"></param>
            <param name="positions"></param>
            <param name="nearest"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.get(System.Int32,System.Int32[],C5.LinkedList{`0}.Node[])">
            <summary>
            Find the node at position pos, given known positions of several nodes.
            </summary>
            <param name="pos"></param>
            <param name="positions"></param>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.getPair(System.Int32,System.Int32,C5.LinkedList{`0}.Node@,C5.LinkedList{`0}.Node@,System.Int32[],C5.LinkedList{`0}.Node[])">
            <summary>
            Get nodes at positions p1 and p2, given nodes at several positions.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="n1"></param>
            <param name="n2"></param>
            <param name="positions"></param>
            <param name="nodes"></param>
        </member>
        <member name="M:C5.LinkedList`1.insert(System.Int32,C5.LinkedList{`0}.Node,`0)">
            <summary>
            
            </summary>
            <param name="index">The index in this view</param>
            <param name="succ"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.fixViewsAfterInsert(C5.LinkedList{`0}.Node,C5.LinkedList{`0}.Node,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="added">The actual number of inserted nodes</param>
            <param name="pred">The predecessor of the inserted nodes</param>
            <param name="succ">The successor of the added nodes</param>
            <param name="realInsertionIndex"></param>
        </member>
        <member name="M:C5.LinkedList`1.viewPosition(C5.LinkedList{`0})">
            <summary>
            
            </summary>
            <param name="otherView"></param>
            <returns>The position of View(otherOffset, otherSize) wrt. this view</returns>
        </member>
        <member name="M:C5.LinkedList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a linked list with en external item equalityComparer
            </summary>
            <param name="itemequalityComparer">The external equalitySCG.Comparer</param>
        </member>
        <member name="M:C5.LinkedList`1.#ctor">
            <summary>
            Create a linked list with the natural item equalityComparer
            </summary>
        </member>
        <member name="T:C5.LinkedList`1.Node">
            <summary>
            An individual cell in the linked list
            </summary>
        </member>
        <member name="T:C5.LinkedList`1.Position">
            <summary>
            During RemoveAll, we need to cache the original endpoint indices of views
            </summary>
        </member>
        <member name="T:C5.LinkedList`1.ViewHandler">
            <summary>
            Handle the update of (other) views during a multi-remove operation.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.ViewHandler.skipEndpoints(System.Int32,System.Int32)">
            <summary>
            This is to be called with realindex pointing to the first node to be removed after a (stretch of) node that was not removed
            </summary>
            <param name="removed"></param>
            <param name="realindex"></param>
        </member>
        <member name="M:C5.LinkedList`1.Dispose">
            <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
        </member>
        <member name="P:C5.LinkedList`1.First">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.LinkedList`1.Last">
            <summary>
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.LinkedList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. THe default for a new linked list is true.</value>
        </member>
        <member name="P:C5.LinkedList`1.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.LinkedList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.LinkedList`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.LinkedList`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.</summary>
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.Insert(C5.IList{`0},`0)">
            <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoint of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para>
            </summary>
            <exception cref="T:C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
            <exception cref="T:System.IndexOutOfRangeException"><b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
            <exception cref="T:C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.LinkedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list.
            </summary>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="equalityComparer">The equalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative</exception>
            <exception cref="T:System.ArgumentException"> if the range does not fit within list.</exception>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.LinkedList`1.ViewOf(`0)">
            <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            </summary>
            <exception cref="T:System.ArgumentException"> if the item is not in this list.</exception>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.LinkedList`1.LastViewOf(`0)">
            <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:System.ArgumentException"/> if the item is not in this list.
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="P:C5.LinkedList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.LinkedList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.LinkedList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for a underlying list.</value>
        </member>
        <member name="M:C5.LinkedList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.LinkedList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, perhaps changing its size.
            </summary>
            <exception cref="T:C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.LinkedList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Span(C5.IList{`0})">
            <summary>
            
            <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
            </summary>
            <param name="otherView"></param>
            <exception cref="T:C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.IsSorted">
            <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.LinkedList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Sort">
            <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class. 
            (<see cref="T:C5.Comparer`1"/>).
            The sorting is stable.
            </summary>
            <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
        </member>
        <member name="M:C5.LinkedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            The sorting is stable.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.LinkedList`1.Shuffle">
            <summary>
            Randomly shuffle the items of this list. 
            <para>Will invalidate overlapping views???</para>
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            <para>Will invalidate overlapping views???</para>
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="P:C5.LinkedList`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="M:C5.LinkedList`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.LinkedList`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.LinkedList`1.GetSequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.SequencedEquals(C5.ISequenced{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.LinkedList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Linear</value>
        </member>
        <member name="M:C5.LinkedList`1.GetUnsequencedHashCode">
            <summary>
            Performs a check for view validity before calling base.GetUnsequencedHashCode()
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. Will update a single item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.LinkedList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.LinkedList`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. Since the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.LinkedList`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found (only one copy). 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <param name="removeditem">The value removed.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            <para>Always removes from the front of the list.
            </para>
            <para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this list, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>.
            </para>
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.LinkedList`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            <para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this collection, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>. The stated complexity 
            holds under the assumption that the itemequalityComparer of this list is well-behaved.
            </para>
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.LinkedList`1.RetainAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:C5.LinkedList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection
            with respect to multiplicities.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.LinkedList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.LinkedList`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            <para>The asymptotic complexity of this method is <code>O(n+v*log(v))</code>, 
            where <code>n</code> is the size of the collection and <code>v</code> 
            is the number of views.
            </para>
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="P:C5.LinkedList`1.Count">
            <summary>
            
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="M:C5.LinkedList`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="filter">The T->bool filter delegate defining the condition</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="M:C5.LinkedList`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.LinkedList`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. 
            </summary>
            <param name="item">The item to add.</param>
            <returns>True.</returns>
        </member>
        <member name="P:C5.LinkedList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True since this collection has bag semantics.</value>
        </member>
        <member name="P:C5.LinkedList`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:C5.LinkedList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.LinkedList`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.LinkedList`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Enqueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.LinkedList`1.Dequeue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="M:C5.LinkedList`1.Check">
            <summary>
            Check the sanity of this list
            </summary>
            <returns>true if sane</returns>
        </member>
        <member name="T:C5.Logger">
            <summary>
            Logging module
            </summary>
        </member>
        <member name="P:C5.Logger.Log">
            <summary>
            Gets or sets the log.
            </summary>
            <example>The following is an example of assigning a observer to the logging module:
              <code>
                Logger.Log = x => Console.WriteLine(x);
              </code>
            </example>
            <remarks>
            If Log is not set it will return a dummy action
            <c>x => { return; })</c>
            eliminating the need for null-reference checks.
            </remarks>
            <value>
            The log.
            </value>
        </member>
        <member name="T:C5.C5Random">
            <summary>
            A modern random number generator based on G. Marsaglia: 
            Seeds for Random Number Generators, Communications of the
            ACM 46, 5 (May 2003) 90-93; and a posting by Marsaglia to 
            comp.lang.c on 2003-04-03.
            </summary>
        </member>
        <member name="M:C5.C5Random.NextDouble">
            <summary>
            Get a new random System.Double value
            </summary>
            <returns>The random double</returns>
        </member>
        <member name="M:C5.C5Random.Sample">
            <summary>
            Get a new random System.Double value
            </summary>
            <returns>The random double</returns>
        </member>
        <member name="M:C5.C5Random.Next">
            <summary>
            Get a new random System.Int32 value
            </summary>
            <returns>The random int</returns>
        </member>
        <member name="M:C5.C5Random.Next(System.Int32)">
            <summary>
            Get a random non-negative integer less than a given upper bound
            </summary>
            <exception cref="T:System.ArgumentException">If max is negative</exception>
            <param name="max">The upper bound (exclusive)</param>
            <returns></returns>
        </member>
        <member name="M:C5.C5Random.Next(System.Int32,System.Int32)">
            <summary>
            Get a random integer between two given bounds
            </summary>
            <exception cref="T:System.ArgumentException">If max is less than min</exception>
            <param name="min">The lower bound (inclusive)</param>
            <param name="max">The upper bound (exclusive)</param>
            <returns></returns>
        </member>
        <member name="M:C5.C5Random.NextBytes(System.Byte[])">
            <summary>
            Fill a array of byte with random bytes
            </summary>
            <param name="buffer">The array to fill</param>
        </member>
        <member name="M:C5.C5Random.#ctor">
            <summary>
            Create a random number generator seed by system time.
            </summary>
        </member>
        <member name="M:C5.C5Random.#ctor(System.Int64)">
            <summary>
            Create a random number generator with a given seed
            </summary>
            <exception cref="T:System.ArgumentException">If seed is zero</exception>
            <param name="seed">The seed</param>
        </member>
        <member name="M:C5.C5Random.#ctor(System.UInt32[])">
            <summary>
            Create a random number generator with a specified internal start state.
            </summary>
            <exception cref="T:System.ArgumentException">If Q is not of length exactly 16</exception>
            <param name="Q">The start state. Must be a collection of random bits given by an array of exactly 16 uints.</param>
        </member>
        <member name="T:C5.Rec`2">
            <summary>
            A generic record type with two fields. 
            <para>
            Equality is defined field by field, using the <code>Equals</code> method 
            inherited from <code>System.Object</code> (i.e. using <see cref="T:C5.NaturalEqualityComparer`1"/>).
            </para>
            <para>
            This type is similar to <see cref="T:C5.KeyValuePair`2"/>, but the latter
            uses <see cref="P:C5.EqualityComparer`1.Default"/> to define field equality instead of <see cref="T:C5.NaturalEqualityComparer`1"/>.
            </para>
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="F:C5.Rec`2.X1">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.Rec`2.X2">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.Rec`2.#ctor(`0,`1)">
            <summary>
            
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
        </member>
        <member name="M:C5.Rec`2.Equals(C5.Rec{`0,`1})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.op_Equality(C5.Rec{`0,`1},C5.Rec{`0,`1})">
            <summary>
            
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.op_Inequality(C5.Rec{`0,`1},C5.Rec{`0,`1})">
            <summary>
            
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`2.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.Rec`3">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
        </member>
        <member name="F:C5.Rec`3.X1">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.Rec`3.X2">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.Rec`3.X3">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.Rec`3.#ctor(`0,`1,`2)">
            <summary>
            
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="x3"></param>
        </member>
        <member name="M:C5.Rec`3.Equals(C5.Rec{`0,`1,`2})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.op_Equality(C5.Rec{`0,`1,`2},C5.Rec{`0,`1,`2})">
            <summary>
            
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.op_Inequality(C5.Rec{`0,`1,`2},C5.Rec{`0,`1,`2})">
            <summary>
            
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`3.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.Rec`4">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
        </member>
        <member name="F:C5.Rec`4.X1">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.Rec`4.X2">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.Rec`4.X3">
            <summary>
            
            </summary>
        </member>
        <member name="F:C5.Rec`4.X4">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.Rec`4.#ctor(`0,`1,`2,`3)">
            <summary>
            
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="x3"></param>
            <param name="x4"></param>
        </member>
        <member name="M:C5.Rec`4.Equals(C5.Rec{`0,`1,`2,`3})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.op_Equality(C5.Rec{`0,`1,`2,`3},C5.Rec{`0,`1,`2,`3})">
            <summary>
            
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.op_Inequality(C5.Rec{`0,`1,`2,`3},C5.Rec{`0,`1,`2,`3})">
            <summary>
            
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.Rec`4.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.Sorting">
            <summary>
            A utility class with functions for sorting arrays with respect to an IComparer&lt;T&gt;
            </summary>
        </member>
        <member name="M:C5.Sorting.IntroSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sort part of array in place using IntroSort
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <code>start</code>
            and <code>count</code> arguments does not describe a valid range.</exception>
            <param name="array">Array to sort</param>
            <param name="start">Index of first position to sort</param>
            <param name="count">Number of elements to sort</param>
            <param name="comparer">IComparer&lt;T&gt; to sort by</param>
        </member>
        <member name="M:C5.Sorting.IntroSort``1(``0[])">
            <summary>
            Sort an array in place using IntroSort and default comparer
            </summary>
            <exception cref="T:C5.NotComparableException">If T is not comparable</exception>
            <param name="array">Array to sort</param>
        </member>
        <member name="M:C5.Sorting.InsertionSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sort part of array in place using Insertion Sort
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <code>start</code>
            and <code>count</code> arguments does not describe a valid range.</exception>
            <param name="array">Array to sort</param>
            <param name="start">Index of first position to sort</param>
            <param name="count">Number of elements to sort</param>
            <param name="comparer">IComparer&lt;T&gt; to sort by</param>
        </member>
        <member name="M:C5.Sorting.HeapSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sort part of array in place using Heap Sort
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <code>start</code>
            and <code>count</code> arguments does not describe a valid range.</exception>
            <param name="array">Array to sort</param>
            <param name="start">Index of first position to sort</param>
            <param name="count">Number of elements to sort</param>
            <param name="comparer">IComparer&lt;T&gt; to sort by</param>
        </member>
        <member name="T:C5.TreeBag`1">
            <summary>
            An implementation of Red-Black trees as an indexed, sorted collection with bag semantics,
            cf. <a href="litterature.htm#CLRS">CLRS</a>. (<see cref="T:C5.TreeBag`1"/> for an 
            implementation with set semantics).
            <br/>
            The comparer (sorting order) may be either natural, because the item type is comparable 
            (generic: <see cref="T:C5.IComparable`1"/> or non-generic: System.IComparable) or it can
            be external and supplied by the user in the constructor.
            <br/>
            Each distinct item is only kept in one place in the tree - together with the number
            of times it is a member of the bag. Thus, if two items that are equal according
            </summary>
        </member>
        <member name="P:C5.TreeBag`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.TreeBag`1.left(C5.TreeBag{`0}.Node)">
            <summary>
            Fetch the left child of n taking node-copying persistence into
            account if relevant. 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:C5.TreeBag`1.Node">
            <summary>
            The type of node in a Red-Black binary tree
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Node.update(C5.TreeBag{`0}.Node@,System.Boolean,C5.TreeBag{`0}.Node,System.Int32,System.Int32)">
            <summary>
            Update a child pointer
            </summary>
            <param name="cursor"></param>
            <param name="leftnode"></param>
            <param name="child"></param>
            <param name="maxsnapid"></param>
            <param name="generation"></param>
            <returns>True if node was *copied*</returns>
        </member>
        <member name="M:C5.TreeBag`1.#ctor">
            <summary>
            Create a red-black tree collection with natural comparer and item equalityComparer.
            We assume that if <code>T</code> is comparable, its default equalityComparer 
            will be compatible with the comparer.
            </summary>
            <exception cref="T:C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
        </member>
        <member name="M:C5.TreeBag`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a red-black tree collection with an external comparer. 
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1"/> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default"/>)
            is unlikely to be compatible with the external comparer. This makes the
            tree inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)
            </para>
            </summary>
            <param name="comparer">The external comparer</param>
        </member>
        <member name="M:C5.TreeBag`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a red-black tree collection with an external comparer and an external
            item equalityComparer, assumed consistent.
            </summary>
            <param name="comparer">The external comparer</param>
            <param name="equalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="T:C5.TreeBag`1.Enumerator">
            <summary>
            An enumerator for a red-black tree collection. Based on an explicit stack
            of subtrees waiting to be enumerated. Currently only used for the tree set 
            enumerators (tree bag enumerators use an iterator block based enumerator).
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.#ctor(C5.TreeBag{`0})">
            <summary>
            Create a tree enumerator
            </summary>
            <param name="tree">The red-black tree to enumerate</param>
        </member>
        <member name="P:C5.TreeBag`1.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the enumerator.</value>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.Dispose">
            <summary>
            Call Dispose(true) and then suppress finalization of this enumerator.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.Dispose(System.Boolean)">
            <summary>
            Remove the internal data (notably the stack array).
            </summary>
            <param name="disposing">True if called from Dispose(),
            false if called from the finalizer</param>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.Finalize">
            <summary>
            Finalizer for enumerator
            </summary>
        </member>
        <member name="T:C5.TreeBag`1.SnapEnumerator">
            <summary>
            An enumerator for a snapshot of a node copy persistent red-black tree
            collection.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.SnapEnumerator.#ctor(C5.TreeBag{`0})">
            <summary>
            Create an enumerator for a snapshot of a node copy persistent red-black tree
            collection
            </summary>
            <param name="tree">The snapshot</param>
        </member>
        <member name="M:C5.TreeBag`1.SnapEnumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.TreeBag`1.SnapEnumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:C5.TreeBag`1.Choose">
            <summary>
            
            </summary>
            <exception cref="T:C5.NoSuchItemException">If tree is empty</exception>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.GetEnumerator">
            <summary>
            Create an enumerator for this tree
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.TreeBag`1.addIterative(`0,`0@,System.Boolean,System.Boolean@)">
            <summary>
            Add item to tree. If already there, return the found item in the second argument.
            </summary>
            <param name="item">Item to add</param>
            <param name="founditem">item found</param>
            <param name="update">whether item in node should be updated</param>
            <param name="wasfound">true if found in bag, false if not found or tree is a set</param>
            <returns>True if item was added</returns>
        </member>
        <member name="M:C5.TreeBag`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.TreeBag`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:C5.TreeBag`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.TreeBag`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para>
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="P:C5.TreeBag`1.AllowsDuplicates">
            <summary></summary>
            <value>True since this collection has bag semantics.</value>
        </member>
        <member name="P:C5.TreeBag`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="P:C5.TreeBag`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="M:C5.TreeBag`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindOrAdd(`0@)">
             <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the existing
             one in the ref argument. 
            
             </summary>
             <param name="item"></param>
             <returns>True if item was found</returns>
        </member>
        <member name="M:C5.TreeBag`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Update(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.UpdateOrAdd(`0)">
             <summary>
             Check if this collection contains an item equivalent according to the
             itemequalityComparer to a particular value. If so, update the item in the collection 
             with a binary copy of the supplied value; else add the value to the collection. 
            
             <i>NOTE: the bag implementation is currently wrong! ?????</i>
             </summary>
             <param name="item">Value to add or update.</param>
             <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.TreeBag`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeBag`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeBag`1.removeIterative(`0@,System.Boolean,System.Int32@)">
            <summary>
            
            </summary>
            <param name="item">input: item to remove; output: item actually removed</param>
            <param name="all">If true, remove all copies</param>
            <param name="wasRemoved"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.TreeBag`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.TreeBag`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.TreeBag`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="P:C5.TreeBag`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:C5.TreeBag`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.TreeBag`1.IndexOf(`0)">
            <summary>
            Searches for an item in this indexed collection going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of first occurrence from start of the item
            if found, else the two-complement 
            (always negative) of the index at which the item would be put if it was added.</returns>
        </member>
        <member name="M:C5.TreeBag`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the tree going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of last occurrence from the end of item if found, 
            else the two-complement (always negative) of the index at which 
            the item would be put if it was added.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="P:C5.TreeBag`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The starting index of the interval (inclusive).</param>
            <param name="count">The length of the interval.</param>
        </member>
        <member name="M:C5.TreeBag`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.TreeBag`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="M:C5.TreeBag`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeBag`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeBag`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeBag`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception>
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decreasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.TreeBag`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.TreeBag`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.TreeBag`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeBag`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeBag`1.Dispose">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Snapshot">
            <summary>
            Make a (read-only) snapshot of this collection.
            </summary>
            <returns>The snapshot.</returns>
        </member>
        <member name="P:C5.TreeBag`1.Range.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:C5.TreeBag`1.Range.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.TreeBag`1.minidump(C5.TreeBag{`0}.Node,System.String)">
            <summary>
            Display this node on the console, and recursively its subnodes.
            </summary>
            <param name="n">Node to display</param>
            <param name="space">Indentation</param>
        </member>
        <member name="M:C5.TreeBag`1.dump">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.dump(System.String)">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.dump(System.String,System.String)">
            <summary>
            Display this tree on the console.
            </summary>
            <param name="msg">Identifying string of this call to dump</param>
            <param name="err">Extra (error)message to include</param>
        </member>
        <member name="M:C5.TreeBag`1.massert(System.Boolean,C5.TreeBag{`0}.Node,System.String)">
            <summary>
            Print warning m on logger if b is false.
            </summary>
            <param name="b">Condition that should hold</param>
            <param name="n">Place (used for id display)</param>
            <param name="m">Message</param>
            <returns>b</returns>
        </member>
        <member name="M:C5.TreeBag`1.Check(System.String)">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <param name="name">Title of dump</param>
            <returns>false if invariant violation</returns>
        </member>
        <member name="M:C5.TreeBag`1.Check">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <returns>false if invariant violation</returns>
        </member>
        <member name="T:C5.TreeDictionary`2">
            <summary>
            A sorted generic dictionary based on a red-black tree set.
            </summary>
        </member>
        <member name="M:C5.TreeDictionary`2.#ctor">
            <summary>
            Create a red-black tree dictionary using the natural comparer for keys.
            <exception cref="T:System.ArgumentException"/> if the key type K is not comparable.
            </summary>
        </member>
        <member name="M:C5.TreeDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a red-black tree dictionary using an external comparer for keys.
            </summary>
            <param name="comparer">The external comparer</param>
        </member>
        <member name="M:C5.TreeDictionary`2.Snapshot">
            <summary>
            Make a snapshot of the current state of this dictionary
            </summary>
            <returns>The snapshot</returns>
        </member>
        <member name="T:C5.TreeSet`1">
             <summary>
             An implementation of Red-Black trees as an indexed, sorted collection with set semantics,
             cf. <a href="litterature.htm#CLRS">CLRS</a>. <see cref="T:C5.TreeBag`1"/> for a version 
             with bag semantics. <see cref="T:C5.TreeDictionary`2"/> for a sorted dictionary 
             based on this tree implementation.
             <i>
             The comparer (sorting order) may be either natural, because the item type is comparable 
             (generic: <see cref="T:C5.IComparable`1"/> or non-generic: System.IComparable) or it can
             be external and supplied by the user in the constructor.</i>
            
             <i>TODO: describe performance here</i>
             <i>TODO: discuss persistence and its useful usage modes. Warn about the space
             leak possible with other usage modes.</i>
             </summary>
        </member>
        <member name="P:C5.TreeSet`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.TreeSet`1.left(C5.TreeSet{`0}.Node)">
            <summary>
            Fetch the left child of n taking node-copying persistence into
            account if relevant. 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:C5.TreeSet`1.Node">
            <summary>
            The type of node in a Red-Black binary tree
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Node.update(C5.TreeSet{`0}.Node@,System.Boolean,C5.TreeSet{`0}.Node,System.Int32,System.Int32)">
            <summary>
            Update a child pointer
            </summary>
            <param name="cursor"></param>
            <param name="leftnode"></param>
            <param name="child"></param>
            <param name="maxsnapid"></param>
            <param name="generation"></param>
            <returns>True if node was *copied*</returns>
        </member>
        <member name="M:C5.TreeSet`1.#ctor">
            <summary>
            Create a red-black tree collection with natural comparer and item equalityComparer.
            We assume that if <code>T</code> is comparable, its default equalityComparer 
            will be compatible with the comparer.
            </summary>
            <exception cref="T:C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
        </member>
        <member name="M:C5.TreeSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a red-black tree collection with an external comparer. 
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1"/> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default"/>)
            is unlikely to be compatible with the external comparer. This makes the
            tree inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)
            </para>
            </summary>
            <param name="comparer">The external comparer</param>
        </member>
        <member name="M:C5.TreeSet`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a red-black tree collection with an external comparer and an external
            item equalityComparer, assumed consistent.
            </summary>
            <param name="comparer">The external comparer</param>
            <param name="equalityComparer">The external item equalitySCG.Comparer</param>
        </member>
        <member name="T:C5.TreeSet`1.Enumerator">
            <summary>
            An enumerator for a red-black tree collection. Based on an explicit stack
            of subtrees waiting to be enumerated. Currently only used for the tree set 
            enumerators (tree bag enumerators use an iterator block based enumerator).
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.#ctor(C5.TreeSet{`0})">
            <summary>
            Create a tree enumerator
            </summary>
            <param name="tree">The red-black tree to enumerate</param>
        </member>
        <member name="P:C5.TreeSet`1.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the enumerator.</value>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.Dispose">
            <summary>
            Call Dispose(true) and then suppress finalization of this enumerator.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.Dispose(System.Boolean)">
            <summary>
            Remove the internal data (notably the stack array).
            </summary>
            <param name="disposing">True if called from Dispose(),
            false if called from the finalizer</param>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.Finalize">
            <summary>
            Finalizer for enumerator
            </summary>
        </member>
        <member name="T:C5.TreeSet`1.SnapEnumerator">
            <summary>
            An enumerator for a snapshot of a node copy persistent red-black tree
            collection.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.SnapEnumerator.#ctor(C5.TreeSet{`0})">
            <summary>
            Create an enumerator for a snapshot of a node copy persistent red-black tree
            collection
            </summary>
            <param name="tree">The snapshot</param>
        </member>
        <member name="M:C5.TreeSet`1.SnapEnumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.TreeSet`1.SnapEnumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:C5.TreeSet`1.Choose">
            <summary>
            
            </summary>
            <exception cref="T:C5.NoSuchItemException">If tree is empty</exception>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.GetEnumerator">
            <summary>
            Create an enumerator for this tree
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.TreeSet`1.addIterative(`0,`0@,System.Boolean,System.Boolean@)">
            <summary>
            Add item to tree. If already there, return the found item in the second argument.
            </summary>
            <param name="item">Item to add</param>
            <param name="founditem">item found</param>
            <param name="update">whether item in node should be updated</param>
            <param name="wasfound">true if found in bag, false if not found or tree is a set</param>
            <returns>True if item was added</returns>
        </member>
        <member name="M:C5.TreeSet`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.TreeSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:C5.TreeSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.TreeSet`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para>
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="P:C5.TreeSet`1.AllowsDuplicates">
            <summary></summary>
            <value>False since this tree has set semantics.</value>
        </member>
        <member name="P:C5.TreeSet`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="P:C5.TreeSet`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="M:C5.TreeSet`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindOrAdd(`0@)">
             <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the existing
             one in the ref argument. 
            
             </summary>
             <param name="item"></param>
             <returns>True if item was found</returns>
        </member>
        <member name="M:C5.TreeSet`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Update(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.UpdateOrAdd(`0)">
             <summary>
             Check if this collection contains an item equivalent according to the
             itemequalityComparer to a particular value. If so, update the item in the collection 
             with a binary copy of the supplied value; else add the value to the collection. 
            
             <i>NOTE: the bag implementation is currently wrong! ?????</i>
             </summary>
             <param name="item">Value to add or update.</param>
             <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.TreeSet`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeSet`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeSet`1.removeIterative(`0@,System.Boolean,System.Int32@)">
            <summary>
            
            </summary>
            <param name="item">input: item to remove; output: item actually removed</param>
            <param name="all">If true, remove all copies</param>
            <param name="wasRemoved"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.TreeSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.TreeSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.TreeSet`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="P:C5.TreeSet`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:C5.TreeSet`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.TreeSet`1.IndexOf(`0)">
            <summary>
            Searches for an item in this indexed collection going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of first occurrence from start of the item
            if found, else the two-complement 
            (always negative) of the index at which the item would be put if it was added.</returns>
        </member>
        <member name="M:C5.TreeSet`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the tree going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of last occurrence from the end of item if found, 
            else the two-complement (always negative) of the index at which 
            the item would be put if it was added.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="P:C5.TreeSet`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The starting index of the interval (inclusive).</param>
            <param name="count">The length of the interval.</param>
        </member>
        <member name="M:C5.TreeSet`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.TreeSet`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="M:C5.TreeSet`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeSet`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeSet`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeSet`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception>
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decreasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.TreeSet`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.TreeSet`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.TreeSet`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeSet`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeSet`1.Dispose">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Snapshot">
            <summary>
            Make a (read-only) snapshot of this collection.
            </summary>
            <returns>The snapshot.</returns>
        </member>
        <member name="P:C5.TreeSet`1.Range.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:C5.TreeSet`1.Range.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.TreeSet`1.minidump(C5.TreeSet{`0}.Node,System.String)">
            <summary>
            Display this node on the console, and recursively its subnodes.
            </summary>
            <param name="n">Node to display</param>
            <param name="space">Indentation</param>
        </member>
        <member name="M:C5.TreeSet`1.dump">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.dump(System.String)">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.dump(System.String,System.String)">
            <summary>
            Display this tree on the console.
            </summary>
            <param name="msg">Identifying string of this call to dump</param>
            <param name="err">Extra (error)message to include</param>
        </member>
        <member name="M:C5.TreeSet`1.massert(System.Boolean,C5.TreeSet{`0}.Node,System.String)">
            <summary>
            Print warning m on logger if b is false.
            </summary>
            <param name="b">Condition that should hold</param>
            <param name="n">Place (used for id display)</param>
            <param name="m">Message</param>
            <returns>b</returns>
        </member>
        <member name="M:C5.TreeSet`1.Check(System.String)">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <param name="name">Title of dump</param>
            <returns>false if invariant violation</returns>
        </member>
        <member name="M:C5.TreeSet`1.Check">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <returns>false if invariant violation</returns>
        </member>
        <member name="T:C5.MutualViewPosition">
            <summary>
            Characterize the mutual position of some view B (other) relative to view A (this)
            </summary>
        </member>
        <member name="F:C5.MutualViewPosition.Contains">
            <summary>
            B contains A(this)
            </summary>
        </member>
        <member name="F:C5.MutualViewPosition.ContainedIn">
            <summary>
            B is containd in A(this), but not vice versa
            </summary>
        </member>
        <member name="F:C5.MutualViewPosition.NonOverlapping">
            <summary>
            A and B does not overlap
            </summary>
        </member>
        <member name="F:C5.MutualViewPosition.Overlapping">
            <summary>
            A and B overlap, but neither is contained in the other
            </summary>
        </member>
        <member name="T:C5.WeakViewList`1">
            <summary>
            This class is shared between the linked list and array list implementations.
            </summary>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:C5.WeakViewList`1.GetEnumerator">
            <summary>
            Note that it is safe to call views.Remove(view.myWeakReference) if view
            is the currently yielded object
            </summary>
            <returns></returns>
        </member>
        <member name="T:C5.WrappedArray`1">
            <summary>
            An advanced interface to operations on an array. The array is viewed as an 
            <see cref="T:C5.IList`1"/> of fixed size, and so all operations that would change the
            size of the array will be invalid (and throw <see cref="T:C5.FixedSizeCollectionException"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:C5.WrappedArray`1.#ctor(`0[])">
            <summary>
            
            </summary>
            <param name="wrappedarray"></param>
        </member>
        <member name="P:C5.WrappedArray`1.First">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.Last">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Map``1(System.Func{`0,``0})">
            <summary>
            
            </summary>
            <typeparam name="V"></typeparam>
            <param name="mapper"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            
            </summary>
            <typeparam name="V"></typeparam>
            <param name="mapper"></param>
            <param name="equalityComparer"></param>
            <returns></returns>
        </member>
        <member name="P:C5.WrappedArray`1.FIFO">
            <summary>
            ???? should we throw NotRelevantException
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.WrappedArray`1.Insert(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.WrappedArray`1.Insert(C5.IList{`0},`0)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.WrappedArray`1.InsertFirst(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.WrappedArray`1.InsertLast(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.WrappedArray`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="items"></param>
        </member>
        <member name="M:C5.WrappedArray`1.Remove">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.RemoveFirst">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.RemoveLast">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.View(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.ViewOf(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.LastViewOf(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:C5.WrappedArray`1.Underlying">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.Offset">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.WrappedArray`1.Slide(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Slide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Span(C5.IList{`0})">
            <summary>
            
            </summary>
            <param name="otherView"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Reverse">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.WrappedArray`1.IsSorted">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            
            </summary>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Sort">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.WrappedArray`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:C5.WrappedArray`1.Shuffle">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.WrappedArray`1.Shuffle(System.Random)">
            <summary>
            
            </summary>
            <param name="rnd"></param>
        </member>
        <member name="P:C5.WrappedArray`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.Item(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.IndexOf(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.LastIndexOf(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.WrappedArray`1.GetSequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.SequencedEquals(C5.ISequenced{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="P:C5.WrappedArray`1.ContainsSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.WrappedArray`1.GetUnsequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Contains(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.ContainsCount(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Find(`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.FindOrAdd(`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Update(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Update(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.UpdateOrAdd(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Remove(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="removeditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.RemoveAllCopies(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.WrappedArray`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.WrappedArray`1.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.WrappedArray`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="items"></param>
        </member>
        <member name="P:C5.WrappedArray`1.IsReadOnly">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.DuplicatesByCounting">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.WrappedArray`1.Add(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.WrappedArray`1.Check">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:C5.WrappedArray`1.ListenableEvents">
            <summary>
            No listeners may be installed
            </summary>
            <value>0</value>
        </member>
        <member name="P:C5.WrappedArray`1.ActiveEvents">
            <summary>
            No listeners ever installed
            </summary>
            <value>0</value>
        </member>
        <member name="E:C5.WrappedArray`1.CollectionChanged">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="E:C5.WrappedArray`1.CollectionCleared">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="E:C5.WrappedArray`1.ItemsAdded">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="E:C5.WrappedArray`1.ItemInserted">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="E:C5.WrappedArray`1.ItemsRemoved">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="E:C5.WrappedArray`1.ItemRemovedAt">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.IsEmpty">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.Count">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.WrappedArray`1.CountSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.WrappedArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:C5.WrappedArray`1.ToArray">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Apply(System.Action{`0})">
            <summary>
            
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:C5.WrappedArray`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Find(System.Func{`0,System.Boolean},`0@)">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.All(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Choose">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.WrappedArray`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:C5.WrappedArray`1.Direction">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.WrappedArray`1.Dispose">
            <summary>
            Dispose this if a view else operation is illegal 
            </summary>
            <exception cref="T:C5.FixedSizeCollectionException">If not a view</exception>
        </member>
        <member name="T:C5.GuardedEnumerator`1">
            <summary>
            A read-only wrapper class for a generic enumerator
            </summary>
        </member>
        <member name="M:C5.GuardedEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Create a wrapper around a generic enumerator
            </summary>
            <param name="enumerator">The enumerator to wrap</param>
        </member>
        <member name="M:C5.GuardedEnumerator`1.MoveNext">
            <summary>
            Move wrapped enumerator to next item, or the first item if
            this is the first call to MoveNext. 
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.GuardedEnumerator`1.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the wrapped enumerator.</value>
        </member>
        <member name="M:C5.GuardedEnumerator`1.Dispose">
            <summary>
            Dispose wrapped enumerator.
            </summary>
        </member>
        <member name="T:C5.GuardedEnumerable`1">
             <summary>
             A read-only wrapper class for a generic enumerable
            
             <i>This is mainly interesting as a base of other guard classes</i>
             </summary>
        </member>
        <member name="M:C5.GuardedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Wrap an enumerable in a read-only wrapper
            </summary>
            <param name="enumerable">The enumerable to wrap</param>
        </member>
        <member name="M:C5.GuardedEnumerable`1.GetEnumerator">
            <summary>
            Get an enumerator from the wrapped enumerable
            </summary>
            <returns>The enumerator (itself wrapped)</returns>
        </member>
        <member name="T:C5.GuardedDirectedEnumerable`1">
             <summary>
             A read-only wrapper for a generic directed enumerable
            
             <i>This is mainly interesting as a base of other guard classes</i>
             </summary>
        </member>
        <member name="M:C5.GuardedDirectedEnumerable`1.#ctor(C5.IDirectedEnumerable{`0})">
            <summary>
            Wrap a directed enumerable in a read-only wrapper
            </summary>
            <param name="directedenumerable">the collection to wrap</param>
        </member>
        <member name="M:C5.GuardedDirectedEnumerable`1.Backwards">
            <summary>
            Get a enumerable that enumerates the wrapped collection in the opposite direction
            </summary>
            <returns>The mirrored enumerable</returns>
        </member>
        <member name="P:C5.GuardedDirectedEnumerable`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.GuardedCollectionValue`1">
             <summary>
             A read-only wrapper for an ICollectionValue&lt;T&gt;
            
             <i>This is mainly interesting as a base of other guard classes</i>
             </summary>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.ListenableEvents">
            <summary>
            The ListenableEvents value of the wrapped collection
            </summary>
            <value></value>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.ActiveEvents">
            <summary>
            The ActiveEvents value of the wrapped collection
            </summary>
            <value></value>
        </member>
        <member name="E:C5.GuardedCollectionValue`1.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:C5.GuardedCollectionValue`1.CollectionCleared">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:C5.GuardedCollectionValue`1.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="E:C5.GuardedCollectionValue`1.ItemInserted">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="E:C5.GuardedCollectionValue`1.ItemsRemoved">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="E:C5.GuardedCollectionValue`1.ItemRemovedAt">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.#ctor(C5.ICollectionValue{`0})">
            <summary>
            Wrap a ICollectionValue&lt;T&gt; in a read-only wrapper
            </summary>
            <param name="collectionvalue">the collection to wrap</param>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.IsEmpty">
            <summary>
            Get the size of the wrapped collection
            </summary>
            <value>The size</value>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.Count">
            <summary>
            Get the size of the wrapped collection
            </summary>
            <value>The size</value>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of the wrapped collection to an array
            </summary>
            <param name="a">The array</param>
            <param name="i">Starting offset</param>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.ToArray">
            <summary>
            Create an array from the items of the wrapped collection
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Apply(System.Action{`0})">
            <summary>
            Apply a delegate to all items of the wrapped enumerable.
            </summary>
            <param name="a">The delegate to apply</param>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in the wrapped enumerable.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter`1"/>) defining the predicate</param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Find(System.Func{`0,System.Boolean},`0@)">
            <summary>
            
            </summary>
            <param name="filter"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.All(System.Func{`0,System.Boolean})">
            <summary>
            Check if all items in the wrapped enumerable satisfies a specific predicate.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter`1"/>) defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="filter">The T->bool filter delegate defining the condition</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="formatProvider"></param>
            <param name="rest"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:C5.GuardedDirectedCollectionValue`1">
             <summary>
             A read-only wrapper for a directed collection
            
             <i>This is mainly interesting as a base of other guard classes</i>
             </summary>
        </member>
        <member name="M:C5.GuardedDirectedCollectionValue`1.#ctor(C5.IDirectedCollectionValue{`0})">
            <summary>
            Wrap a directed collection in a read-only wrapper
            </summary>
            <param name="directedcollection">the collection to wrap</param>
        </member>
        <member name="M:C5.GuardedDirectedCollectionValue`1.Backwards">
            <summary>
            Get a collection that enumerates the wrapped collection in the opposite direction
            </summary>
            <returns>The mirrored collection</returns>
        </member>
        <member name="M:C5.GuardedDirectedCollectionValue`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:C5.GuardedDirectedCollectionValue`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.GuardedCollection`1">
            <summary>
            A read-only wrapper for an <see cref="T:C5.ICollection`1"/>,
            <para>
            <i>Suitable for wrapping hash tables, <see cref="T:C5.HashSet`1"/>
            and <see cref="T:C5.HashBag`1"/>  </i></para>
            </summary>
        </member>
        <member name="M:C5.GuardedCollection`1.#ctor(C5.ICollection{`0})">
            <summary>
            Wrap an ICollection&lt;T&gt; in a read-only wrapper
            </summary>
            <param name="collection">the collection to wrap</param>
        </member>
        <member name="P:C5.GuardedCollection`1.IsReadOnly">
            <summary>
            (This is a read-only wrapper)
            </summary>
            <value>True</value>
        </member>
        <member name="P:C5.GuardedCollection`1.ContainsSpeed">
            <summary> </summary>
            <value>Speed of wrapped collection</value>
        </member>
        <member name="M:C5.GuardedCollection`1.GetUnsequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.UnsequencedEquals(C5.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Contains(`0)">
            <summary>
            Check if an item is in the wrapped collection
            </summary>
            <param name="item">The item</param>
            <returns>True if found</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item appears in the wrapped collection
            </summary>
            <param name="item">The item</param>
            <returns>The number of copies</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in the argument is in the wrapped collection
            </summary>
            <param name="items">The items</param>
            <returns>True if so</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Find(`0@)">
            <summary> 
            Search for an item in the wrapped collection
            </summary>
            <param name="item">On entry the item to look for, on exit the equivalent item found (if any)</param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.FindOrAdd(`0@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Update(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Update(`0,`0@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.UpdateOrAdd(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.UpdateOrAdd(`0,`0@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Remove(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Remove(`0,`0@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.RemoveAllCopies(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.Clear">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
        </member>
        <member name="M:C5.GuardedCollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.Check">
            <summary>
            Check  wrapped collection for internal consistency
            </summary>
            <returns>True if check passed</returns>
        </member>
        <member name="P:C5.GuardedCollection`1.AllowsDuplicates">
            <summary> </summary>
            <value>False if wrapped collection has set semantics</value>
        </member>
        <member name="P:C5.GuardedCollection`1.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.GuardedCollection`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="P:C5.GuardedCollection`1.IsEmpty">
            <summary> </summary>
            <value>True if wrapped collection is empty</value>
        </member>
        <member name="M:C5.GuardedCollection`1.Add(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="items"></param>
        </member>
        <member name="T:C5.GuardedSequenced`1">
             <summary>
             A read-only wrapper for a sequenced collection
            
             <i>This is mainly interesting as a base of other guard classes</i>
             </summary>
        </member>
        <member name="M:C5.GuardedSequenced`1.#ctor(C5.ISequenced{`0})">
            <summary>
            Wrap a sequenced collection in a read-only wrapper
            </summary>
            <param name="sorted"></param>
        </member>
        <member name="M:C5.GuardedSequenced`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:C5.GuardedSequenced`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:C5.GuardedSequenced`1.GetSequencedHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSequenced`1.SequencedEquals(C5.ISequenced{`0})">
            <summary>
            
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSequenced`1.Backwards">
            <summary>
            Get a collection that enumerates the wrapped collection in the opposite direction
            </summary>
            <returns>The mirrored collection</returns>
        </member>
        <member name="M:C5.GuardedSequenced`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            
            </summary>
            <param name="predicate"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:C5.GuardedSequenced`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.GuardedSorted`1">
             <summary>
             A read-only wrapper for a sorted collection
            
             <i>This is mainly interesting as a base of other guard classes</i>
             </summary>
        </member>
        <member name="M:C5.GuardedSorted`1.#ctor(C5.ISorted{`0})">
            <summary>
            Wrap a sorted collection in a read-only wrapper
            </summary>
            <param name="sorted"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the guarded sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the guarded sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the guarded sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.Predecessor(`0)">
            <summary>
            Find the predecessor of the item in the wrapped sorted collection
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists </exception>    
            <param name="item">The item</param>
            <returns>The predecessor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.Successor(`0)">
            <summary>
            Find the Successor of the item in the wrapped sorted collection
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists </exception>    
            <param name="item">The item</param>
            <returns>The Successor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor of the item in the wrapped sorted collection
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists </exception>    
            <param name="item">The item</param>
            <returns>The weak predecessor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.WeakSuccessor(`0)">
            <summary>
            Find the weak Successor of the item in the wrapped sorted collection
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such element exists </exception>    
            <param name="item">The item</param>
            <returns>The weak Successor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Run Cut on the wrapped sorted collection
            </summary>
            <param name="c"></param>
            <param name="low"></param>
            <param name="lval"></param>
            <param name="high"></param>
            <param name="hval"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeFrom(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeTo(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeAll">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.RemoveRangeFrom(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="low"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="low"></param>
            <param name="hi"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.RemoveRangeTo(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="hi"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.FindMin">
            <summary>
            Find the minimum of the wrapped collection
            </summary>
            <returns>The minimum</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.DeleteMin">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.FindMax">
            <summary>
            Find the maximum of the wrapped collection
            </summary>
            <returns>The maximum</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.DeleteMax">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="P:C5.GuardedSorted`1.Comparer">
            <summary>
            The comparer object supplied at creation time for the underlying collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:C5.GuardedIndexedSorted`1">
             <summary>
             Read-only wrapper for indexed sorted collections
            
             <i>Suitable for wrapping TreeSet, TreeBag and SortedArray</i>
             </summary>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.#ctor(C5.IIndexedSorted{`0})">
            <summary>
            Wrap an indexed sorted collection in a read-only wrapper
            </summary>
            <param name="list">the indexed sorted collection</param>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RangeFrom(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RangeTo(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.CountFrom(`0)">
            <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.CountFromTo(`0,`0)">
            <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.CountTo(`0)">
            <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Run FindAll on the wrapped collection with the indicated filter.
            The result will <b>not</b> be read-only.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Run Map on the wrapped collection with the indicated mapper.
            The result will <b>not</b> be read-only.
            </summary>
            <param name="m"></param>
            <param name="c">The comparer to use in the result</param>
            <returns></returns>
        </member>
        <member name="P:C5.GuardedIndexedSorted`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <value>The i'th item of the wrapped sorted collection</value>
        </member>
        <member name="P:C5.GuardedIndexedSorted`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.GuardedIndexedSorted`1.Item(System.Int32,System.Int32)">
            <summary> </summary>
            <value>A directed collection of the items in the indicated interval of the wrapped collection</value>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.IndexOf(`0)">
            <summary>
            Find the (first) index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.LastIndexOf(`0)">
            <summary>
            Find the last index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RemoveAt(System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="T:C5.GuardedList`1">
            <summary>
            A read-only wrapper for a generic list collection
            <i>Suitable as a wrapper for LinkedList, HashedLinkedList, ArrayList and HashedArray.
            <see cref="T:C5.LinkedList`1"/>, 
            <see cref="T:C5.HashedLinkedList`1"/>, 
            <see cref="T:C5.ArrayList`1"/> or
            <see cref="T:C5.HashedArray`1"/>.
            </i>
            </summary>
        </member>
        <member name="M:C5.GuardedList`1.#ctor(C5.IList{`0})">
            <summary>
            Wrap a list in a read-only wrapper.  A list gets wrapped as read-only,
            a list view gets wrapped as read-only and non-slidable.
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="P:C5.GuardedList`1.First">
            <summary>
            
            </summary>
            <value>The first item of the wrapped list</value>
        </member>
        <member name="P:C5.GuardedList`1.Last">
            <summary>
            
            </summary>
            <value>The last item of the wrapped list</value>
        </member>
        <member name="P:C5.GuardedList`1.FIFO">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> if used as setter</exception>
            <value>True if wrapped list has FIFO semantics for the Add(T item) and Remove() methods</value>
        </member>
        <member name="P:C5.GuardedList`1.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:C5.GuardedList`1.Item(System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> if used as setter</exception>
            <value>The i'th item of the wrapped list</value>
        </member>
        <member name="P:C5.GuardedList`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.GuardedList`1.Insert(System.Int32,`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.Insert(C5.IList{`0},`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertFirst(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertLast(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertBefore(`0,`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <param name="target"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertAfter(`0,`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="item"></param>
            <param name="target"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="i"></param>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Perform FindAll on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
            <param name="filter">The filter to use</param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Perform Map on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The mapper to use.</param>
            <returns>The mapped list</returns>
        </member>
        <member name="M:C5.GuardedList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Perform Map on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="itemequalityComparer">The itemequalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.GuardedList`1.Remove">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveFirst">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveLast">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.View(System.Int32,System.Int32)">
            <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.ViewOf(`0)">
            <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.LastViewOf(`0)">
            <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:C5.GuardedList`1.Underlying">
            <summary>
            </summary>
            <value>The wrapped underlying list of the wrapped view </value>
        </member>
        <member name="P:C5.GuardedList`1.Offset">
            <summary>
            
            </summary>
            <value>The offset of the wrapped list as a view.</value>
        </member>
        <member name="P:C5.GuardedList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.GuardedList`1.Slide(System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> if this is a wrapped view and not a view that was made on a wrapper</exception>
            <param name="offset"></param>
        </member>
        <member name="M:C5.GuardedList`1.Slide(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="offset"></param>
            <param name="size"></param>
        </member>
        <member name="M:C5.GuardedList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.Span(C5.IList{`0})">
            <summary>
            
            </summary>
            <param name="otherView"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.Reverse">
            <summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            </summary>
        </member>
        <member name="M:C5.GuardedList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.GuardedList`1.IsSorted">
            <summary>
            Check if wrapped list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.GuardedList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if wrapped list is sorted
            </summary>
            <param name="c">The sorting order to use</param>
            <returns>True if sorted</returns>
        </member>
        <member name="M:C5.GuardedList`1.Sort">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
        </member>
        <member name="M:C5.GuardedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="c"></param>
        </member>
        <member name="M:C5.GuardedList`1.Shuffle">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
        </member>
        <member name="M:C5.GuardedList`1.Shuffle(System.Random)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="rnd"></param>
        </member>
        <member name="P:C5.GuardedList`1.Item(System.Int32,System.Int32)">
            <summary> </summary>
            <value>A directed collection of the items in the indicated interval of the wrapped collection</value>
        </member>
        <member name="M:C5.GuardedList`1.IndexOf(`0)">
            <summary>
            Find the (first) index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.LastIndexOf(`0)">
            <summary>
            Find the last index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveAt(System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.GuardedList`1.Push(`0)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.Pop">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.Enqueue(`0)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.Dequeue">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.Dispose">
            <summary>
            Ignore: this may be called by a foreach or using statement.
            </summary>
        </member>
        <member name="T:C5.GuardedQueue`1">
            <summary>
            A read-only wrapper for a generic indexable queue (allows indexing).
            
            <para>Suitable for wrapping a <see cref="T:C5.CircularQueue`1"/></para>
            </summary>
            <typeparam name="T">The item type.</typeparam>
        </member>
        <member name="M:C5.GuardedQueue`1.#ctor(C5.IQueue{`0})">
            <summary>
            Wrap a queue in a read-only wrapper
            </summary>
            <param name="queue">The queue</param>
        </member>
        <member name="P:C5.GuardedQueue`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.GuardedQueue`1.Item(System.Int32)">
            <summary>
            Index into the wrapped queue
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedQueue`1.Enqueue(`0)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedQueue`1.Dequeue">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns>-</returns>
        </member>
        <member name="T:C5.GuardedDictionary`2">
             <summary>
             A read-only wrapper for a dictionary.
            
             <i>Suitable for wrapping a HashDictionary. <see cref="T:C5.HashDictionary`2"/></i>
             </summary>
        </member>
        <member name="M:C5.GuardedDictionary`2.#ctor(C5.IDictionary{`0,`1})">
            <summary>
            Wrap a dictionary in a read-only wrapper
            </summary>
            <param name="dict">the dictionary</param>
        </member>
        <member name="P:C5.GuardedDictionary`2.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Item(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a
            read-only wrapper if used as a setter</exception>
            <value>Get the value corresponding to a key in the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.IsReadOnly">
            <summary>
            (This is a read-only wrapper)
            </summary>
            <value>True</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Keys">
            <summary> </summary>
            <value>The collection of keys of the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Values">
            <summary> </summary>
            <value>The collection of values of the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Func">
            <summary>
            
            </summary>
        </member>
        <member name="M:C5.GuardedDictionary`2.Add(`0,`1)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
        </member>
        <member name="M:C5.GuardedDictionary`2.AddAll``2(System.Collections.Generic.IEnumerable{C5.KeyValuePair{``0,``1}})">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedDictionary`2.Remove(`0)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Remove(`0,`1@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Clear">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
        </member>
        <member name="P:C5.GuardedDictionary`2.ContainsSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.GuardedDictionary`2.Contains(`0)">
            <summary>
            Check if the wrapped dictionary contains a specific key
            </summary>
            <param name="key">The key</param>
            <returns>True if it does</returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Find(`0@,`1@)">
            <summary>
            Search for a key in the wrapped dictionary, reporting the value if found
            </summary>
            <param name="key">The key</param>
            <param name="val">On exit: the value if found</param>
            <returns>True if found</returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Update(`0,`1)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Update(`0,`1,`1@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
            <param name="oldval"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.FindOrAdd(`0,`1@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.UpdateOrAdd(`0,`1)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.UpdateOrAdd(`0,`1,`1@)">
            <summary>
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="key"></param>
            <param name="val"></param>
            <param name="oldval"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Check">
            <summary>
            Check the internal consistency of the wrapped dictionary
            </summary>
            <returns>True if check passed</returns>
        </member>
        <member name="T:C5.GuardedSortedDictionary`2">
             <summary>
             A read-only wrapper for a sorted dictionary.
            
             <i>Suitable for wrapping a Dictionary. <see cref="T:C5.Dictionary`2"/></i>
             </summary>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.#ctor(C5.ISortedDictionary{`0,`1})">
            <summary>
            Wrap a sorted dictionary in a read-only wrapper
            </summary>
            <param name="sorteddict">the dictionary</param>
        </member>
        <member name="P:C5.GuardedSortedDictionary`2.Comparer">
            <summary>
            The key comparer used by this dictionary.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.GuardedSortedDictionary`2.Keys">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.TryPredecessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a predecessor</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.TrySuccessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The successor, if any</param>
            <returns>True if the key has a successor</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.TryWeakPredecessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a weak predecessor</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.TryWeakSuccessor(`0,C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The weak successor, if any</param>
            <returns>True if the key has a weak successor</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.Predecessor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            predecessor of a specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such entry exists </exception>    
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.Successor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            successor of a specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such entry exists </exception>    
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.WeakPredecessor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            weak predecessor of a specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such entry exists </exception>    
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.WeakSuccessor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            weak successor of a specified key.
            </summary>
            <exception cref="T:C5.NoSuchItemException"> if no such entry exists </exception>    
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.FindMin">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.DeleteMin">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.FindMax">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.DeleteMax">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.Cut(System.IComparable{`0},C5.KeyValuePair{`0,`1}@,System.Boolean@,C5.KeyValuePair{`0,`1}@,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="c"></param>
            <param name="lowEntry"></param>
            <param name="lowIsValid"></param>
            <param name="highEntry"></param>
            <param name="highIsValid"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RangeFrom(`0)">
            <summary>
            
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RangeFromTo(`0,`0)">
            <summary>
            
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RangeTo(`0)">
            <summary>
            
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RangeAll">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.AddSorted(System.Collections.Generic.IEnumerable{C5.KeyValuePair{`0,`1}})">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RemoveRangeFrom(`0)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="low"></param>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RemoveRangeFromTo(`0,`0)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="low"></param>
            <param name="hi"></param>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.RemoveRangeTo(`0)">
            <summary>
            
            </summary>
            <exception cref="T:C5.ReadOnlyCollectionException"> since this is a read-only wrapper</exception>
            <param name="hi"></param>
        </member>
    </members>
</doc>
